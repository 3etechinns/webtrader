/**
 * Created by Arnab Karmakar on 1/16/16.
 */
/**
 * Initialize a new indicator object
 * @param data in [{time, open, high, low, close}, {time, open, high, low, close}] format
 * @param options - Indicator parameters passed from UI (user selection)
 * @constructor
 */
IndicatorBase = function(data, options, indicators) {

    this.options = options;
    //Calculate the initial value and store locally
    this.indicatorData = [];
    /*
        This variable can also contain array of IDs, for example BBANDs indicator
     */
    this.uniqueID = uuid();
    this.indicators = indicators;

};

/**
 * Adds a new Indicator point at the end
 * This can return [ { time : , value : []}] - Meaning, the value can also return array of
 *                                              values, for example BBANDS indicator
 *                                              Value can also be an instance of CDLUpdateObject, for example all the CDL indicators
 * @param data
 * @returns {*[]}
 */
IndicatorBase.prototype.addPoint = function(data) {
    return [];
};

/**
 * Updates the last Indicator point
 * This can return [ { time : , value : []}] - Meaning, the value can also return array of
 *                                              values, for example BBANDS indicator
 *                                              Value can also be an instance of CDLUpdateObject, for example all the CDL indicators
 * @param data
 * @returns {*[]}
 */
IndicatorBase.prototype.update = function(data) {
    return [];
};

/**
 * @returns {string}
 */
IndicatorBase.prototype.toString = function() {
    return 'IndicatorBase';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
IndicatorBase.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    var data = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function(e) {
        data.push([e.time, e.value]);
    });
    var confObject = {
        axisConf : { // Secondary yAxis
            id: indicatorMetadata.id + '-' + this.uniqueID,
            title: {
                text: this.toString(),
                align: 'high',
                offset: 0,
                rotation: 0,
                y: 10, //Trying to show title inside the indicator chart
                x: 30+ this.toString().length * 7.5
            },
            lineWidth: 2,
            plotLines: this.options.levels,
            plotBands :this.options.plotBands
        },
        seriesConf : {
            id: this.uniqueID,
            name: this.toString(),
            data: data,
            type: 'line',
            yAxis: indicatorMetadata.id + '-' + this.uniqueID,
            color: this.options.stroke,
            lineWidth: this.options.strokeWidth,
            dashStyle: this.options.dashStyle
        }
    };
    if (indicatorMetadata.onChartIndicator) {
        delete confObject.axisConf;
        delete confObject.seriesConf.yAxis;
        confObject.seriesConf.onChartIndicator = true;
    }
    return [confObject];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
IndicatorBase.prototype.getIDs = function() {
    return [this.uniqueID];
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
IndicatorBase.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), [this.uniqueID]);
};

/**
 * Created by Arnab Karmakar on 1/16/16.
 */
STDDEV = function(data, options, indicators) {

    if (_.isUndefined(options.appliedTo)) {
        options.appliedTo = indicators.CLOSE;
    }
    IndicatorBase.call(this, data, options, indicators);
    this.sma = new SMA(data, options, indicators);
    this.priceData = [];

    /*
     * Formula -
     // Standard Deviation :
     // 	1-Calculate the average (mean) price for the number of periods or observations.
     // 	2-Determine each period's deviation (close less average price).
     // 	3-Square each period's deviation.
     // 	4-Sum the squared deviations.
     // 	5-Divide this sum by the number of observations.
     // 	6-The standard deviation is then equal to the square root of that number.
     */
    for (var index = 0; index < data.length; index++)
    {
        if (index >= options.period) {
            var sum = 0.0;
            for (var i = this.options.period - 1; i >= 0; i--) {
                sum += Math.pow(indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo) - this.sma.indicatorData[index - i].value, 2)
            }
            var stddev = Math.sqrt(sum / (this.options.period - 1));
            this.indicatorData.push({
                time: data[index].time,
                value: toFixed(stddev, 4)
            });
        }
        else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

STDDEV.prototype = Object.create(IndicatorBase.prototype);
STDDEV.prototype.constructor = STDDEV;

/**
 * @param data
 * @returns {*[]}
 */
STDDEV.prototype.addPoint = function(data) {
    this.priceData.push(data);
    this.sma.addPoint(data);
    var index = this.priceData.length - 1;
    var sum = 0.0;
    for (var i = this.options.period - 1; i >= 0; i--) {
        var val = Math.pow(this.indicators.getIndicatorOrPriceValue(this.priceData[index - i], this.options.appliedTo) - this.sma.indicatorData[index - i].value, 2);
        sum += val;
    }
    var stddev = toFixed(Math.sqrt(sum / (this.options.period - 1)), 4);
    this.indicatorData.push({
        time: data.time,
        value: stddev
    });
    return [{
        id : this.uniqueID,
        value : stddev
    }];
};

/**
 * @param data
 * @returns {*[]}
 */
STDDEV.prototype.update = function(data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    this.sma.update(data);
    var sum = 0.0;
    for (var i = this.options.period - 1; i >= 0; i--) {
        sum += Math.pow(this.indicators.getIndicatorOrPriceValue(this.priceData[index - i], this.options.appliedTo) - this.sma.indicatorData[index - i].value, 2)
    }
    var stddev = toFixed(Math.sqrt(sum / (this.options.period - 1)), 4);
    this.indicatorData[this.indicatorData.length - 1].value = stddev;
    return [{
        id : this.uniqueID,
        value : stddev
    }];
};

/**
 * @returns {string}
 */
STDDEV.prototype.toString = function() {
    return 'STDDEV (' + this.options.period + ')';
};

STDDEV.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    var confObjects = IndicatorBase.prototype.buildSeriesAndAxisConfFromData.call(this, indicatorMetadata);
    confObjects.forEach(function(confObject) {
        confObject.axisConf.title.x = 30+ this.toString().length * 7.5;
    });
    return confObjects;
};

/**
 * Created by Arnab Karmakar on 1/13/16.
 */

/**
 * Initialize a new ATR indicator
 * @param data in [{time, open, high, low, close}, {time, open, high, low, close}] format
 * @param options - ATR parameters passed from UI (user selection)
 * @constructor
 */
ATR = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.tr = [];
    this.priceData = [];
    /*
     * Formula -
     * 	tr(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]
     * 	atr(t) = (atr(t-1) x (n - 1) + tr(t)) / n
     * 		t - current
     * 		n - period
     */
    //Calculate ATR data
    for (var index = 0; index < data.length; index++)
    {

        //Calculate TR - start
        if (index == 0)
        {
            this.tr.push({
                time: data[index].time,
                value: data[index].high - data[index].low
            });
        }
        else
        {
            var price = indicators.getIndicatorOrPriceValue(data[index - 1], this.options.appliedTo);
            this.tr.push({
                time: data[index].time,
                value: Math.max(Math.max(data[index].high - data[index].low, Math.abs(data[index].high - price))
                    , data[index].low - price
                )
            });
        }
        //Calculate TR - end

        //Calculate ATR - start
        if (index >= options.period)
        {
            var atrValue = (this.indicatorData[index - 1].value * (options.period - 1) + this.tr[index].value) / options.period;
            if (isFinite(atrValue) && !isNaN(atrValue))
            {
                this.indicatorData.push({
                    time: data[index].time,
                    value: toFixed(atrValue, 4)
                });
            }
        }
        else
        {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
        //Calculate ATR - end
         this.priceData.push(data[index]);
    }
};

ATR.prototype = Object.create(IndicatorBase.prototype);
ATR.prototype.constructor = ATR;

/**
 * Adds a new ATR point at the end
 * @param data
 * @returns {*[]}
 */
ATR.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    /*tr(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]
    atr(t) = (atr(t-1) x (n - 1) + tr(t)) / n*/
    var prePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - 1], this.options.appliedTo);
    var trValue = Math.max(Math.max(data.high - data.low, Math.abs(data.high - prePrice)), (data.low - prePrice));
    var atrValue = toFixed(((this.indicatorData[index - 1].value * (this.options.period - 1) + trValue) / this.options.period), 4);
    this.indicatorData.push({
        time : data.time,
        value : atrValue
    });
    this.tr.push({
        time : data.time,
        value : trValue
    });
    return [{
        id : this.uniqueID,
        value : atrValue
    }];
};

/**
 * Updates the last ATR point
 * @param data
 * @returns {*[]}
 */
ATR.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    /*tr(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]
    atr(t) = (atr(t-1) x (n - 1) + tr(t)) / n*/
    var prePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - 1], this.options.appliedTo);
    var trValue = Math.max(Math.max(data.high - data.low, Math.abs(data.high - prePrice)), (data.low - prePrice));
    var atrValue = toFixed(((this.indicatorData[index - 1].value * (this.options.period - 1) + trValue) / this.options.period), 4);
    this.indicatorData[this.indicatorData.length - 1].value = atrValue;
    this.tr[this.indicatorData.length - 1].value = trValue;
    return [{
        id : this.uniqueID,
        value : atrValue
    }];
};

/**
 * @returns {string}
 */
ATR.prototype.toString = function() {
    return 'ATR (' + this.options.period + ')';
};

/**
 * Created by Arnab Karmakar on 1/16/16.
 */
BOP = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);

    /*
     * Formula -
         BOP = (CL - OP) / (HI - LO)
     */
    //Calculate BOP data
    for (var index = 0; index < data.length; index++)
    {
        var closePrice = data[index].close;
        var openPrice = data[index].open;
        var highPrice = data[index].high;
        var lowPrice = data[index].low;
        var bopValue = 0;
        if ((highPrice - lowPrice) !== 0) { bopValue = (closePrice - openPrice) / (highPrice - lowPrice); };
        this.indicatorData.push({
            time: data[index].time,
            value: toFixed(bopValue, 4)
        });
    }
};

BOP.prototype = Object.create(IndicatorBase.prototype);
BOP.prototype.constructor = BOP;

/**
 * @param data
 * @returns {*[]}
 */
BOP.prototype.addPoint = function(data) {
    var closePrice = data.close;
    var openPrice = data.open;
    var highPrice = data.high;
    var lowPrice = data.low;
    var bopValue = 0;
    if ((highPrice - lowPrice) !== 0) { bopValue = (closePrice - openPrice) / (highPrice - lowPrice) };
    this.indicatorData.push({
        time : data.time,
        value : bopValue
    });
    return [{
        id : this.uniqueID,
        value : bopValue
    }];
};

/**
 * @param data
 * @returns {*[]}
 */
BOP.prototype.update = function(data) {
    var closePrice = data.close;
    var openPrice = data.open;
    var highPrice = data.high;
    var lowPrice = data.low;
    var bopValue = 0;
    if ((highPrice - lowPrice) !== 0) { bopValue = (closePrice - openPrice) / (highPrice - lowPrice) };
    this.indicatorData[this.indicatorData.length - 1].value = bopValue;
    return [{
        id : this.uniqueID,
        value : bopValue
    }];
};

/**
 * @returns {string}
 */
BOP.prototype.toString = function() {
    return ' BOP';
};

BOP.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    var confObjects = IndicatorBase.prototype.buildSeriesAndAxisConfFromData.call(this, indicatorMetadata);
    confObjects.forEach(function(confObject) {
        confObject.seriesConf.type = 'column';
    });
    return confObjects;
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

NATR = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*Calculate ATR
    NATR = ATR(n) / Close * 100
    Where: ATR(n) = Average True Range over ‘n’ periods.*/
    this.atr = new window['ATR'](data, options, indicators);

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var price = indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var natr = toFixed(((this.atr.indicatorData[index].value / price) * 100), 4);
            this.indicatorData.push({ time: data[index].time, value: natr });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

NATR.prototype = Object.create(IndicatorBase.prototype);
NATR.prototype.constructor = NATR;

NATR.prototype.addPoint = function (data) {
    console.log('Adding NATR data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var atr = this.atr.addPoint(data)[0].value;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var natr = toFixed(((atr / price) * 100), 4);
    this.indicatorData.push({ time: data.time, value: natr });
    return [{
        id: this.uniqueID,
        value: natr
    }];
};

NATR.prototype.update = function (data) {
    console.log('Updating NATR data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var atr = this.atr.update(data)[0].value;;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var natr = toFixed(((atr / price) * 100), 4);
    this.indicatorData[index].value = natr;
    return [{
        id: this.uniqueID,
        value: natr
    }];
};

NATR.prototype.toString = function () {
    return 'NATR (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};


/**
 * Created by Mahboob.M on 1/29/16.
 */

ROCP = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*
    * Formula(OHLC or Candlestick) -
    * ROCP = [(Close - Close n periods ago) / (Close n periods ago)]
    * n - period
    */
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period)) {
            var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var nPrePrice = this.indicators.getIndicatorOrPriceValue(data[index - this.options.period], this.options.appliedTo);
            var rocp = toFixed(((price - nPrePrice) / nPrePrice), 4);
            this.indicatorData.push({ time: data[index].time, value: rocp });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

ROCP.prototype = Object.create(IndicatorBase.prototype);
ROCP.prototype.constructor = ROCP;

ROCP.prototype.addPoint = function (data) {
    console.log('Adding ROCP data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var rocp = toFixed(((price - nPrePrice) / nPrePrice), 4);
    this.indicatorData.push({ time: data.time, value: rocp });
    return [{
        id: this.uniqueID,
        value: rocp
    }];
};

ROCP.prototype.update = function (data) {
    console.log('Updating ROCP data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var rocp = toFixed(((price - nPrePrice) / nPrePrice), 4);
    this.indicatorData[index].value = rocp;
    return [{
        id: this.uniqueID,
        value: rocp
    }];
};

ROCP.prototype.toString = function () {
    return 'ROCP (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

ROCR = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*
    * Formula(OHLC or Candlestick) -
    *  ROCR = Current Price / Price of n bars ago
    * n - period
    */
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period)) {
            var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var nPrePrice = this.indicators.getIndicatorOrPriceValue(data[index - this.options.period], this.options.appliedTo);
            var rocr = toFixed((price / nPrePrice), 4);
            this.indicatorData.push({ time: data[index].time, value: rocr });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

ROCR.prototype = Object.create(IndicatorBase.prototype);
ROCR.prototype.constructor = ROCR;

ROCR.prototype.addPoint = function (data) {
    console.log('Adding ROCR data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var rocr = toFixed((price / nPrePrice), 4);
    this.indicatorData.push({ time: data.time, value: rocr });
    return [{
        id: this.uniqueID,
        value: rocr
    }];
};

ROCR.prototype.update = function (data) {
    console.log('Updating ROCR data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var rocr = toFixed((price / nPrePrice), 4);
    this.indicatorData[index].value = rocr;
    return [{
        id: this.uniqueID,
        value: rocr
    }];
};

ROCR.prototype.toString = function () {
    return 'ROCR (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

WILLR = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.calculateWILLRValue = function (data, index) {
        /* WILLR :
         %R = -100 * ( ( Highest High - Close) / (Highest High - Lowest Low ) )*/
        var highestHigh = data[index].high;
        var lowestLow = data[index].close;
        for (var i = 0; i < this.options.period; i++) {
            highestHigh = Math.max(highestHigh, data[index - i].high);
            lowestLow = Math.min(lowestLow, data[index - i].low);
        }
        var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        var willr = (-100 * (highestHigh - price)) / (highestHigh - lowestLow);
        return toFixed(willr, 4);;
    };
    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var willr = this.calculateWILLRValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: willr });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

WILLR.prototype = Object.create(IndicatorBase.prototype);
WILLR.prototype.constructor = WILLR;

WILLR.prototype.addPoint = function (data) {
    console.log('Adding WILLR data point : ', data);
    this.priceData.push(data);
    var willr = this.calculateWILLRValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: willr });
    return [{
        id: this.uniqueID,
        value: willr
    }];
};

WILLR.prototype.update = function (data) {
    console.log('Updating WILLR data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var willr = this.calculateWILLRValue(this.priceData, index);
    this.indicatorData[index].value = willr;
    return [{
        id: this.uniqueID,
        value: willr
    }];
};

WILLR.prototype.toString = function () {
    return 'WILLR (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/6/16.
 */

ADX = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*Current High - Previous High = UpMove
    Current Low - Previous Low = DownMove
    If UpMove > DownMove and UpMove > 0, then +DM = UpMove, else +DM = 0
    If DownMove > Upmove and Downmove > 0, then -DM = DownMove, else -DM = 0
    +DI = 100 times Exponential Moving Average of (+DM / Average True Range)
    -DI = 100 times Exponential Moving Average of (-DM / Average True Range)
    ADX = 100 times the Exponential Moving Average of the Absolute Value of (+DI- -DI) / (+DI + -DI).*/
    this.atr = new ATR(data, options, indicators);

    this.calculateDMValue = function (data, index) {
        var upMove = data[index].high - data[index - 1].high;
        var downMove = data[index].low - data[index - 1].low;
        var plusDm = 0, minusDM = 0;
        if (upMove > downMove && upMove > 0)
            plusDm = upMove;
        if (downMove > upMove && downMove > 0)
            minusDM = downMove;
        return {
            plusDm: plusDm,
            minusDM: minusDM
        }
    };

    this.calculateDMData = function (data) {
        var plusDMData = [{ time: data[0].time, close: 0 }], minusDMData = [{ time: data[0].time, close: 0 }];
        for (var index = 1; index < data.length; index++) {
            var Dm = this.calculateDMValue(data, index);
            if (this.atr.indicatorData[index].value === 0) {
                plusDMData.push({ time: data[0].time, close: 0 });
                minusDMData.push({ time: data[0].time, close: 0 });
            }
            else {
                plusDMData.push({ time: data[index].time, close: (Dm.plusDm / this.atr.indicatorData[index].value) });
                minusDMData.push({ time: data[index].time, close: (Dm.minusDM / this.atr.indicatorData[index].value) });
            };
        };
        return {
            plusDMData: plusDMData,
            minusDMData: minusDMData
        }
    };

    var DM = this.calculateDMData(data);
    this.PlusDI = new window[this.options.maType](DM.plusDMData, {maType:this.options.maType ,period:this.options.period}, indicators);
    this.MinusDI = new window[this.options.maType](DM.minusDMData, {maType:this.options.maType ,period:this.options.period}, indicators);

    var maData = [];
    var index = 0, _this=this;
    this.PlusDI.indicatorData.forEach(function (plusDI) {
        var minusDI = _this.MinusDI.indicatorData[index];
        if ((plusDI.value + minusDI.value) === 0) {
            maData.push({ time: plusDI.time, close: 0 });
        } else {
            maData.push({ time: plusDI.time, close: Math.abs((plusDI.value - minusDI.value) / (plusDI.value + minusDI.value)) });
        };
        _this.priceData.push(data[index]);
        index++;
    });

    this.adxdata = new window[this.options.maType](maData, { maType: this.options.maType, period: this.options.period }, indicators);
    this.indicatorData = this.adxdata.indicatorData;
};

ADX.prototype = Object.create(IndicatorBase.prototype);
ADX.prototype.constructor = ADX;

ADX.prototype.addPoint = function (data) {
    console.log('Adding ADX data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var atr = this.atr.addPoint(data)[0].value;
    var DM = this.calculateDMValue(this.priceData, index);
    var plusDI = this.PlusDI.addPoint({ time: data.time, close: (atr === 0 ? 0 : DM.plusDm / atr) })[0].value;
    var minusDI = this.MinusDI.addPoint({ time: data.time, close: (atr === 0 ? 0 : DM.minusDM / atr) })[0].value;
    var adxValue = (plusDI + minusDI) === 0 ? 0 : Math.abs((plusDI - minusDI) / (plusDI + minusDI));
    var adx = this.adxdata.addPoint({ time: data.time, close: adxValue })[0].value;
    this.indicatorData = this.adxdata.indicatorData;
    return [{
        id: this.uniqueID,
        value: adx
    }];
};

ADX.prototype.update = function (data) {
    console.log('Updating ADX data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var atr = this.atr.update(data)[0].value;
    var DM = this.calculateDMValue(this.priceData, index);
    var plusDI = this.PlusDI.update({ time: data.time, close: (atr === 0 ? 0 : DM.plusDm / atr) })[0].value;
    var minusDI = this.MinusDI.update({ time: data.time, close: (atr === 0 ? 0 : DM.minusDM / atr) })[0].value;
    var adxValue = (plusDI + minusDI) === 0 ? 0 : Math.abs((plusDI - minusDI) / (plusDI + minusDI));
    var adx = this.adxdata.update({ time: data.time, close: adxValue })[0].value;
    this.indicatorData = this.adxdata.indicatorData;
    return [{
        id: this.uniqueID,
        value: adx
    }];
};

ADX.prototype.toString = function () {
    return 'ADX (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/7/16.
 */

ADXR = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    /*ADXR = ADXR[i] = (ADX[i] + ADX[i-n]) / 2*/
    this.adx = new ADX(data, options, indicators);
    for (var index = 0; index < data.length ; index++)
    {
        if (index >= this.options.period) {
            var adxr = (this.adx.indicatorData[index].value + this.adx.indicatorData[index - this.options.period].value) / 2
            this.indicatorData.push({ time: data[index].time, value: toFixed(adxr, 4) });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        };
    }
    
};

ADXR.prototype = Object.create(IndicatorBase.prototype);
ADXR.prototype.constructor = ADXR;

ADXR.prototype.addPoint = function (data) {
    console.log('Adding ADXR data point : ', data);
    var adx = this.adx.addPoint(data)[0].value;
    var index = this.adx.indicatorData.length - 1;
    var adxr = (adx + this.adx.indicatorData[index - this.options.period].value) / 2;
    this.indicatorData.push({ time: data.time, value: toFixed(adxr, 4) });
    return [{
        id: this.uniqueID,
        value: adxr
    }];
};

ADXR.prototype.update = function (data) {
    console.log('Updating ADXR data point : ', data);
    var adx = this.adx.update(data)[0].value;
    var index = this.adx.indicatorData.length - 1;
    var adxr = (adx + this.adx.indicatorData[index - this.options.period].value) / 2;
    this.indicatorData[index].value = toFixed(adxr, 4);
    return [{
        id: this.uniqueID,
        value: adxr
    }];
};

ADXR.prototype.toString = function () {
    return  'ADXR (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/2/16.
 */

ALMA = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateALMAValue = function (data, index) {
        /* ALMA :
        $sigma = 6;
        $offset = 0.85;
        $m = $offset * ($period - 1);
        $s = $period / $sigma;
        $sum = 0;
        $norm = 0;
        for ($i = 0; $i < $period; $i++) {
	        $coeff = exp (- ($i - $m) * ($i - $m) / 2 * $s * $s);
	        $sum += $data[$period - $i ] * $coeff;
	        $norm += $coeff;
        }
        return $sum / $norm;*/
        console.info(this.options.sigma, this.options.offset, this.options.period);
        var m = Math.floor(this.options.offset * (this.options.period - 1));
        var s = this.options.period / this.options.sigma;
        var sum = 0.0;
        var norm = 0;
        for (var i = 0; i < this.options.period; i++) {
            var coeff = Math.exp(-(Math.pow((i - m), 2) / (2 * Math.pow(s, 2))));
            sum += this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo) * coeff;
            norm += coeff; 
        }
        var alma = 0;
        if (norm !== 0)
            alma = sum / norm;
        return toFixed(alma, 4);
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var alma = this.CalculateALMAValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: alma });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

ALMA.prototype = Object.create(IndicatorBase.prototype);
ALMA.prototype.constructor = ALMA;

ALMA.prototype.addPoint = function (data) {
    console.log('Adding ALMA data point : ', data);
    this.priceData.push(data);
    var alma = this.CalculateALMAValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: alma });
    return [{
        id: this.uniqueID,
        value: alma
    }];
};

ALMA.prototype.update = function (data) {
    console.log('Updating ALMA data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var alma = this.CalculateALMAValue(this.priceData, index);
    this.indicatorData[index].value = alma;
    return [{
        id: this.uniqueID,
        value: alma
    }];
};

ALMA.prototype.toString = function () {
    return 'ALMA (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/3/16.
 */
AO = function (data, options, indicators) {

    options.shortMaType = (options.shortMaType || 'SMA').toUpperCase();
    options.longMaType = (options.longMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    var shortOptions = { maType: options.shortMaType, period: options.shortPeriod },
        longOprions = { maType: options.longMaType, period: options.longPeriod };
   
    this.getBarColor = function (index) {
        var color = this.options.aoHighStroke;
        if (index > 1 && this.indicatorData[index].value < this.indicatorData[index - 1].value) {
            color = this.options.aoLowStroke;
        };
        return color;
    };
    /*
    AO = SMA(High+Low)/2, 5 Periods) - SMA(High+Low/2, 34 Periods)
    */
    var MedianData = [];
    for (var index = 0; index < data.length; index++) {
        var medVAlue = (data[index].high + data[index].low) / 2;
        MedianData.push({ time: data[index].time, close: medVAlue });
    };

    this.shortMa = new window[options.shortMaType](MedianData, shortOptions, indicators);
    this.longMa = new window[options.longMaType](MedianData, longOprions, indicators);

    var index = 0;
    var _this = this;
    this.shortMa.indicatorData.forEach(function (shortMa) {
        var aoValue = toFixed((shortMa.value - _this.longMa.indicatorData[index].value), 4);
        _this.indicatorData.push({ time: data[index].time, value: aoValue });
        index++;
    });
};

AO.prototype = Object.create(IndicatorBase.prototype);
AO.prototype.constructor = AO;

AO.prototype.addPoint = function (data) {
    var medVAlue = (data.high + data.low) / 2;
    var shortMa = this.shortMa.addPoint({ time: data.time, close: medVAlue })[0].value;
    var longMa = this.longMa.addPoint({ time: data.time, close: medVAlue })[0].value;
    var aoValue = toFixed((shortMa - longMa), 4);
    this.indicatorData.push({ time: data.time, value: aoValue });
    return [{
        id: this.uniqueID,
        value: aoValue,
        color: this.getBarColor(this.indicatorData.length - 1)
    }];
};

AO.prototype.update = function (data) {
    var index = this.indicatorData.length - 1;
    var medVAlue = (data.high + data.low) / 2;
    var shortMa = this.shortMa.update({ time: data.time, close: medVAlue })[0].value;
    var longMa = this.longMa.update({ time: data.time, close: medVAlue })[0].value;
    var aoValue = toFixed((shortMa - longMa), 4);
    this.indicatorData[index].value = aoValue;
    return [{
        id: this.uniqueID,
        value: aoValue
    }];
};

AO.prototype.toString = function () {
    return 'AO (' + this.options.shortPeriod + ', ' + this.options.longPeriod  + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
AO.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    var aoData = [];
    var colors = [];
    //Prepare the data before sending a configuration
    for (var index = 0; index < this.indicatorData.length; index++) {
        var data = this.indicatorData[index];
        aoData.push([data.time, data.value]);
        colors.push(this.getBarColor(index));
    };

    return [{
        axisConf: { // Secondary yAxis
            id: indicatorMetadata.id + '-' + this.uniqueID,
            title: {
                text: this.toString(),
                align: 'high',
                offset: 0,
                rotation: 0,
                y: 10, 
                x: 30+ this.toString().length * 7.5
            },
            lineWidth: 2,
            plotLines: this.options.levels
             }
        },
        {
             seriesConf: {
                 id: this.uniqueID,
                 name: this.toString(),
                 data: aoData,
                 type: 'column',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID,
                 onChartIndicator: false,
                 colorByPoint:true,
                 colors: colors
             }
        }];
};


/**
 * Created by Mahboob.M on 2/7/16.
 */
APO = function (data, options, indicators) {

    options.fastMaType = (options.fastMaType || 'SMA').toUpperCase();
    options.slowMaType = (options.slowMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    var slowOptions = { maType: options.slowMaType, period: options.slowPeriod, appliedTo: options.appliedTo },
        fastOprions = { maType: options.fastMaType, period: options.fastPeriod, appliedTo: options.appliedTo };
    this.fastMa = new window[options.fastMaType](data, fastOprions, indicators);
    this.slowMa = new window[options.slowMaType](data, slowOptions, indicators);

    /* APO = Fast Moving Average - Slow Moving Average */
    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.slowPeriod) {
            var apoValue = toFixed((this.fastMa.indicatorData[index].value - this.slowMa.indicatorData[index].value), 4);
            this.indicatorData.push({ time: data[index].time, value: apoValue });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        };
    }
};

APO.prototype = Object.create(IndicatorBase.prototype);
APO.prototype.constructor = APO;

APO.prototype.addPoint = function (data) {
    var fastMa = this.fastMa.addPoint(data)[0].value;
    var slowMa = this.slowMa.addPoint(data)[0].value;
    var apoValue = toFixed((fastMa - slowMa), 4);
    this.indicatorData.push({ time: data.time, value: apoValue });
    return [{
        id: this.uniqueID,
        value: apoValue
    }];
};

APO.prototype.update = function (data) {
    var index = this.indicatorData.length - 1;
    var fastMa = this.fastMa.update(data)[0].value;
    var slowMa = this.slowMa.update(data)[0].value;
    var apoValue = toFixed((fastMa - slowMa), 4);
    this.indicatorData[index].value = apoValue;
    return [{
        id: this.uniqueID,
        value: apoValue
    }];
};

APO.prototype.toString = function () {
    return 'APO (' + this.options.fastPeriod + ', ' + this.options.slowPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/3/16.
 */

AROON = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.aroonDownData = [];

     //2 unique IDs for 2 series to be rendered
    //aroonUp and aroonDown
    this.uniqueID = [uuid(), uuid()];

    this.CalculateAROONValue = function (data, index) {
        /* AROON :
        Aroon-Up = ((25 - Days Since 25-day High)/25) x 100
        Aroon-Down = ((25 - Days Since 25-day Low)/25) x 100*/
        var max = data[index].high;
        var min = data[index].low;
        var HH = 0, LL = 0;
        for (var i = 0; i < this.options.period; i++) {
            if (data[index - i].high > max) {
                max = data[index - i].high;
                HH = i;
            }
            if (data[index - i].low < min) {
                min = data[index - i].low;
                LL = i;
            }
        };

        var aroonUp = ((this.options.period - HH) / this.options.period) * 100;
        var aroonDown = ((this.options.period - LL) / this.options.period) * 100;
        return {
            aroonUp: aroonUp,
            aroonDown: aroonDown
        };
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var aroon = this.CalculateAROONValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: aroon.aroonUp });
            this.aroonDownData.push({ time : data[index].time, value : aroon.aroonDown });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
            this.aroonDownData.push({ time : data[index].time, value : 0 });
        }
        this.priceData.push(data[index]);
    }
};

AROON.prototype = Object.create(IndicatorBase.prototype);
AROON.prototype.constructor = AROON;

AROON.prototype.addPoint = function (data) {
    console.log('Adding AROON data point : ', data);
    this.priceData.push(data);
    var aroon = this.CalculateAROONValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: aroon.aroonUp });
    this.aroonDownData.push({ time : data.time, value : aroon.aroonDown });
    return [{
        id : this.uniqueID[0],
        value :  aroon.aroonUp
    }, {
        id : this.uniqueID[1],
        value : aroon.aroonDown
    }];
};

AROON.prototype.update = function (data) {
    console.log('Updating AROON data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var aroon = this.CalculateAROONValue(this.priceData, index);
    this.indicatorData[index].value = aroon.aroonUp;
    this.aroonDownData[index].value = aroon.aroonDown;
    return [{
        id : this.uniqueID[0],
        value :  aroon.aroonUp
    }, {
        id : this.uniqueID[1],
        value : aroon.aroonDown
    }];
};

AROON.prototype.toString = function () {
    return 'AROON (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};


/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
AROON.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    var aroonUpData = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function (e) {
        aroonUpData.push([e.time, e.value]);
    });
    var aroonDownData = [];
    this.aroonDownData.forEach(function (e) {
        aroonDownData.push([e.time, e.value]);
    });


    return [{
            axisConf: { // Secondary yAxis
                id: indicatorMetadata.id + '-' + this.uniqueID[0],
                title: {
                    text: this.toString(),
                    align: 'high',
                    offset: 0,
                    rotation: 0,
                    y: 10, 
                    x: 30+ this.toString().length * 7.5
                },
                lineWidth: 2,
                plotLines: this.options.levels
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: 'AROONUP - ' + this.toString(),
                 data: aroonUpData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.aroonUpStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[1],
                 name: 'AROONDOWN - ' + this.toString(),
                 data: aroonDownData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.aroonDownStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         }];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
AROON.prototype.getIDs = function () {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
AROON.prototype.isSameInstance = function (uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Mahboob.M on 2/3/16.
 */

AROONOSC = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];

    this.CalculateAROONOSCValue = function (data, index) {
        /* AROONOSC :
        Aroon Up = 100 x (25 - Days Since 25-day High)/25
        Aroon Down = 100 x (25 - Days Since 25-day Low)/25
        Aroon Oscillator = Aroon-Up  -  Aroon-Down*/
        var max = data[index].high;
        var min = data[index].low;
        var HH = 0, LL = 0;
        for (var i = 0; i < this.options.period; i++) {
            if (data[index - i].high > max) {
                max = data[index - i].high;
                HH = i;
            }
            if (data[index - i].low < min) {
                min = data[index - i].low;
                LL = i;
            }
        };
        var aroonUp = ((this.options.period - HH) / this.options.period) * 100;
        var aroonDown = ((this.options.period - LL) / this.options.period) * 100;
        return (aroonUp - aroonDown);
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var aroonosc = this.CalculateAROONOSCValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: aroonosc });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

AROONOSC.prototype = Object.create(IndicatorBase.prototype);
AROONOSC.prototype.constructor = AROONOSC;

AROONOSC.prototype.addPoint = function (data) {
    console.log('Adding AROONOSC data point : ', data);
    this.priceData.push(data);
    var aroonosc = this.CalculateAROONOSCValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: aroonosc });
    return [{
        id: this.uniqueID,
        value: aroonosc
    }];
};

AROONOSC.prototype.update = function (data) {
    console.log('Updating AROONOSC data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var aroonosc = this.CalculateAROONOSCValue(this.priceData, index);
    this.indicatorData[index].value = aroonosc;
    return [{
        id: this.uniqueID,
        value: aroonosc
    }];
};

AROONOSC.prototype.toString = function () {
    return 'AROONOSC (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
BBANDS = function(data, options, indicators) {

    options.maType = (options.maType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    this.ma = new window[options.maType](data, options, indicators);
    this.stddev = new STDDEV(data, options, indicators);
    this.indicatorData = this.ma.indicatorData;
    this.upperBandData = [];
    this.lowerBandData = [];
    this.areaRangeData = [];
    //4 unique IDs for 4 series to be rendered
    //middle, upper, lower, arearange
    this.uniqueID = [uuid(), uuid(), uuid(), uuid()];

    /*
     Bollinger Bands:
     * Middle Band = 20-day simple moving average (SMA)
     * Upper Band = 20-day SMA + (20-day standard deviation of price x 2)
     * Lower Band = 20-day SMA - (20-day standard deviation of price x 2)
     */
    for (var index = 0; index < data.length; index++) {
        var upper = toFixed(this.ma.indicatorData[index].value + this.stddev.indicatorData[index].value * options.devUp, 4);
        var lower = toFixed(this.ma.indicatorData[index].value - this.stddev.indicatorData[index].value * options.devDn, 4);
        this.upperBandData.push({ time : data[index].time, value : upper });
        this.lowerBandData.push({ time : data[index].time, value : lower });
        this.areaRangeData.push({ time : data[index].time, value : [upper, lower] });
    }

};

BBANDS.prototype = Object.create(IndicatorBase.prototype);
BBANDS.prototype.constructor = BBANDS;

BBANDS.prototype.addPoint = function(data) {
    var ma = this.ma.addPoint(data)[0].value;
    var stddev = this.stddev.addPoint(data)[0].value;
    var upper = toFixed(ma + stddev * this.options.devUp, 4);
    var lower = toFixed(ma - stddev * this.options.devDn, 4);
    this.indicatorData = this.ma.indicatorData;
    this.upperBandData.push({ time : data.time, value : upper });
    this.lowerBandData.push({ time : data.time, value : lower });
    this.areaRangeData.push({ time : data.time, value : [upper, lower] });
    return [{
        id : this.uniqueID[0],
        value : ma
    }, {
        id : this.uniqueID[1],
        value : upper
    }, {
        id : this.uniqueID[2],
        value : lower
    }, {
        id : this.uniqueID[3],
        value : [upper, lower]
    }];
};

BBANDS.prototype.update = function(data) {
    var index = this.indicatorData.length - 1;
    var ma = this.ma.update(data)[0].value;
    var stddev = this.stddev.update(data)[0].value;
    var upper = toFixed(ma + stddev * this.options.devUp, 4);
    var lower = toFixed(ma - stddev * this.options.devDn, 4);
    this.indicatorData = this.ma.indicatorData;
    this.upperBandData[index].value = upper;
    this.lowerBandData[index].value = lower;
    this.areaRangeData[index].value = [upper, lower];
    return [{
        id : this.uniqueID[0],
        value : ma
    }, {
        id : this.uniqueID[1],
        value : upper
    }, {
        id : this.uniqueID[2],
        value : lower
    }, {
        id : this.uniqueID[3],
        value : [upper, lower]
    }];
};

BBANDS.prototype.toString = function() {
    return 'BBANDS (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ', ' + this.options.devUp + ', ' + this.options.devDn + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
BBANDS.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    var middleData = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function(e) {
        middleData.push([e.time, e.value]);
    });
    var upperData = [];
    this.upperBandData.forEach(function(e) {
        upperData.push([e.time, e.value]);
    });
    var lowerData = [];
    this.lowerBandData.forEach(function(e) {
        lowerData.push([e.time, e.value]);
    });
    var rangeData = [];
    this.areaRangeData.forEach(function(e) {
        rangeData.push(_.flattenDeep([e.time, e.value]));
    });
    return [
        {
            seriesConf : {
                id: this.uniqueID[0],
                name: 'Middle - ' + this.toString(),
                data: middleData,
                type: 'line',
                color: this.options.stroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf : {
                id: this.uniqueID[1],
                name: 'Upper - ' + this.toString(),
                data: upperData,
                type: 'line',
                color: this.options.stroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf : {
                id: this.uniqueID[2],
                name: 'Lower - ' + this.toString(),
                data: lowerData,
                type: 'line',
                color: this.options.stroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf: {
                id: this.uniqueID[3],
                data: rangeData,
                name: "BBANDS Range",
                type: 'arearange',
                color: 'white',
                fillColor: this.options.backgroundColor,
                connectNulls: true,
                //Following properties, states, events, dataLabels, point are needed. Otherwise higcharts-more throws error
                states: {
                    hover: {
                        enabled: false
                    }
                },
                events: {},
                dataLabels: {
                    enabled: false
                },
                point: {
                    events: {}
                },
                enableMouseTracking: false,
                onChartIndicator: true
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
BBANDS.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
BBANDS.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Mahboob.M on 5/2/16.
 */

CC = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    /* Coppock = WMA[10] of  (ROC[14] + ROC[11]).*/
    this.shortRoc = new ROC(data, { period: options.shortRocPeriod, appliedTo: options.appliedTo }, indicators);
    this.longRoc = new ROC(data, { period: options.longRocPeriod, appliedTo: options.appliedTo }, indicators);

    rocData=[];
    for (var index = 0; index < data.length; index++) {
        rocData.push({ time: data[index].time, close: this.shortRoc.indicatorData[index].value + this.longRoc.indicatorData[index].value });
    };

    this.wmaData = new WMA(rocData, { period: options.wmaPeriod }, indicators);
    this.indicatorData = this.wmaData.indicatorData;
};

CC.prototype = Object.create(IndicatorBase.prototype);
CC.prototype.constructor = CC;

CC.prototype.addPoint = function (data) {
    console.log('Adding CC data point : ', data);
    var shortRoc = this.shortRoc.addPoint(data)[0].value;
    var longRoc = this.longRoc.addPoint(data)[0].value;
    var cc = this.wmaData.addPoint({ time: data.time, close: shortRoc + longRoc })[0].value;
    this.indicatorData = this.wmaData.indicatorData;
    return [{
        id: this.uniqueID,
        value: cc
    }];
};

CC.prototype.update = function (data) {
    console.log('Updating CC data point : ', data);
    var shortRoc = this.shortRoc.update(data)[0].value;
    var longRoc = this.longRoc.update(data)[0].value;
    var cc = this.wmaData.update({ time: data.time, close: shortRoc + longRoc })[0].value;
    this.indicatorData = this.wmaData.indicatorData;
    return [{
        id: this.uniqueID,
        value: cc
    }];
};

CC.prototype.toString = function () {
    return 'CC (' + this.options.shortRocPeriod + ', ' + this.options.longRocPeriod + ', ' + this.options.wmaPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

CCI = function (data, options, indicators) {

    options.maType = (options.maType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    this.tpData = [];
    this.priceData = [];
    this.CalculateCCIValue = function (data, index) {
        /* Calculate CCI
         CCI = ( M - A ) / ( 0.015 * D )
         Where:
         M = ( H + L + C ) / 3
         H = Highest price for the period
         L = Lowest price for the period
         C = Closing price for the period
         A = n period moving average of M
         D = mean deviation of the absolute value of the difference between the mean price and the moving average of mean prices, M - A
         */

        //*mean deviation of the absolute value of the difference between the mean price and  the moving average of mean prices, M - A
        var sum = 0;
        for (var i = 0; i < this.options.period - 1; i++) {
            sum += Math.abs(this.tpMa.indicatorData[index].value - this.tpData[index - i].close);
        }
        var mDevValue = sum / this.options.period;
        //* Calculate CCI
        //* CCI = ( M - A ) / ( 0.015 * D )
        var cciValue = toFixed(((this.tpData[index].close - this.tpMa.indicatorData[index].value) / (.015 * mDevValue)), 4);
        return cciValue;
    };

    //*Calculate Mean Deviation
    //*the moving average of mean prices
    for (var index = 0; index < data.length; index++) {
        var tpValue = (data[index].high + data[index].low  + data[index].close) / 3;
        this.tpData.push({ time: data[index].time, close: tpValue });
    };
    options.appliedTo = this.indicators.CLOSE;
    this.tpMa = new window[this.options.maType](this.tpData, options, indicators);

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var cci = this.CalculateCCIValue(data, index, false);
            this.indicatorData.push({ time: data[index].time, value: cci });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};




CCI.prototype = Object.create(IndicatorBase.prototype);
CCI.prototype.constructor = CCI;

CCI.prototype.addPoint = function (data) {
    console.log('Adding CCI data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var tpValue = (this.priceData[index].high + this.priceData[index].low + this.priceData[index].close) / 3;
    this.tpData.push({ time: data.time, close: tpValue });
    this.tpMa.addPoint(this.tpData[index]);
    var cci = this.CalculateCCIValue(this.priceData, this.priceData.length - 1 ,false);
    this.indicatorData.push({ time: data.time, value: cci });
    return [{
        id: this.uniqueID,
        value: cci
    }];
};

CCI.prototype.update = function (data) {
    console.log('Updating CCI data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var tpValue = (this.priceData[index].high + this.priceData[index].low + this.priceData[index].close) / 3;
    this.tpData[index].close = tpValue;
    this.tpMa.update(this.tpData[index]);
    var cci = this.CalculateCCIValue(this.priceData, index, false);
    this.indicatorData[index].value = cci;
    return [{
        id: this.uniqueID,
        value: cci
    }];
};

CCI.prototype.toString = function () {
    return 'CCI (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Arnab Karmakar on 1/23/16.
 */
CDL = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    //Size of this.priceData and this.indicatorData might not be same because we are
    // not going to add indicator data when there is no pattern

    this.priceData.push(data[0]);
    this.priceData.push(data[1]);
    for (var index = 2; index < data.length; index++)
    {
        this.priceData.push(data[index]);
        var retRenderingCode = this.calculateIndicatorValue(this.options.cdlIndicatorCode);
        if (retRenderingCode)
        {
            this.indicatorData.push(retRenderingCode);
        }
    }

};

CDL.prototype = Object.create(IndicatorBase.prototype);
CDL.prototype.constructor = CDL;

CDL.prototype.addPoint = function(data) {
    this.priceData.push(data);
    var ret = this.calculateIndicatorValue(this.options.cdlIndicatorCode)|| {};
    if(ret.text)
    {
        this.indicatorData.push(ret);
    }
    return [{
        id : this.uniqueID,
        value : new CDLUpdateObject(ret.x || data.time, ret.title, ret.text)
    }];
};

CDL.prototype.update = function(data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    var ret = this.calculateIndicatorValue(this.options.cdlIndicatorCode) || {};
    if(ret.text)
    {
        this.indicatorData[index] = ret;
    }
    return [{
        id : this.uniqueID,
        value : new CDLUpdateObject(ret.x || data.time, ret.title, ret.text)
    }];
};

CDL.prototype.toString = function() {
    return this.indicators.getIndicatorsJSONData()[this.options.cdlIndicatorCode].long_display_name;
};

CDL.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    return [
        {
            seriesConf : {
                id: this.uniqueID,
                name: this.toString(),
                data: this.indicatorData,
                type: 'flags',
                dashStyle: this.options.dashStyle,
                onChartIndicator: true,
                onSeries: this.options.onSeriesID, //Series ID on which this flags will be rendered
                shape: 'flag',
                turboThreshold: 0
            }
        }
    ];
};

CDLUpdateObject = function(x, title, text) {
    this.x = x;
    this.title = title;
    this.text = text;
    this.toJSObject = function() {
        return {
            x : x,
            title : title,
            text : text
        };
    };
};

CDL.prototype.CDL2CROWS = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBearishContinuation = params.isCandleThree_Bullish
        && params.isCandleTwo_Bearish && (params.candleTwo_Open > params.candleThree_Close && params.candleTwo_Close > params.candleThree_Close)
        && params.isCandleOne_Bearish
        && (params.candleOne_Open < params.candleTwo_Open && params.candleOne_Open > params.candleTwo_Close) //opens within the prior candle's body
        && (params.candleOne_Close < params.candleThree_Close && params.candleOne_Close > params.candleThree_Open); //and closes within the body of the first candle in the pattern
    var isBullishContinuation = params.isCandleThree_Bearish
        && params.isCandleTwo_Bullish && (params.candleTwo_Open < params.candleThree_Close && params.candleTwo_Close < params.candleThree_Close)
        && params.isCandleOne_Bullish
        && (params.candleOne_Open > params.candleTwo_Open && params.candleOne_Open < params.candleTwo_Close) //opens within the prior candle's body
        && (params.candleOne_Close > params.candleThree_Close && params.candleOne_Close < params.candleThree_Open); //and closes within the body of the first candle in the pattern
    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLDOJI = function(open, high, low, close) {
    var isOpenCloseSame = (open === close),
        differenceBet_Open_High = Math.abs(open - high),
        differenceBet_Open_Low = Math.abs(open - low),
        candleBodySize = Math.abs(low - high),
        realBodySize = Math.abs(open - close);

    //Either open and close is same or difference between Open and Close is 1% of the total size of candle
    var isBearishContinuation = (isOpenCloseSame || ((candleBodySize * 0.05) >= realBodySize))
        && differenceBet_Open_High < differenceBet_Open_Low;

    var isBullishContinuation = (isOpenCloseSame || ((candleBodySize * 0.05) >= realBodySize))
        && differenceBet_Open_High > differenceBet_Open_Low;

    var isDoji = (isOpenCloseSame || ((candleBodySize * 0.05) >= realBodySize)) && (differenceBet_Open_High > realBodySize) && (differenceBet_Open_Low > realBodySize);

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation,
        isDoji:isDoji
    };
};

CDL.prototype.CDL3BLACKCROWS = function() {
    var params = CDLGETPARAMS(this.priceData);
    var isBearishContinuation = false;
    if (params.candleFour_Index >= 0) {
        isBearishContinuation = params.isCandleThree_Bearish && params.isCandleTwo_Bearish && params.isCandleOne_Bearish
            && params.candleThree_Close < params.candleFour_Low && params.candleTwo_Close < params.candleThree_Low && params.candleOne_Close < params.candleTwo_Low //closed lower than the previous day
            && _.inRange(params.candleThree_Open, params.candleFour_Close, params.candleFour_Open)
            && _.inRange(params.candleTwo_Open, params.candleThree_Close, params.candleThree_Open)
            && _.inRange(params.candleOne_Open, params.candleTwo_Close, params.candleTwo_Open); //opening within the body of the previous day;
    }
    //It's a bearish candlestick
    var isBullishContinuation = false;
    return {
        isBull : isBullishContinuation,
        isBear : isBearishContinuation
    };
};

CDL.prototype.CDL3INSIDE = function() {
    var params = CDLGETPARAMS(this.priceData);
    var isBearishContinuation = params.isCandleThree_Bullish
        && params.isCandleTwo_Bearish && _.inRange(params.candleTwo_Open, params.candleThree_Open, params.candleThree_Close) && _.inRange(params.candleTwo_Close, params.candleThree_Open, params.candleThree_Close)
        && params.isCandleOne_Bearish && (params.candleOne_Close < params.candleTwo_Close);
    var isBullishContinuation = params.isCandleThree_Bearish
        && params.isCandleTwo_Bullish && _.inRange(params.candleTwo_Open, params.candleThree_Close, params.candleThree_Open) && _.inRange(params.candleTwo_Close, params.candleThree_Close, params.candleThree_Open)
        && params.isCandleOne_Bullish && (params.candleOne_Close > params.candleTwo_Close);
    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
};

CDL.prototype.CDL3LINESTRIKE = function() {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;
    if (params.candleFour_Index >= 0) {
        isBullishContinuation = params.isCandleFour_Bearish
                 && params.isCandleThree_Bearish && (params.candleThree_Close < params.candleFour_Close)
                 && params.isCandleTwo_Bearish && (params.candleTwo_Close < params.candleThree_Close)
                 && params.isCandleOne_Bullish && (params.candleOne_Close > params.candleFour_Open && params.candleOne_Open < params.candleTwo_Close);

        isBearishContinuation = params.isCandleFour_Bullish
                && params.isCandleThree_Bullish && (params.candleThree_Close > params.candleFour_Close)
                && params.isCandleTwo_Bullish && (params.candleTwo_Close > params.candleThree_Close)
                && params.isCandleOne_Bearish && (params.candleOne_Close < params.candleFour_Open && params.candleOne_Open < params.candleTwo_Close);
    }
    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
};

CDL.prototype.CDL3OUTSIDE = function() {
    var params = CDLGETPARAMS(this.priceData);
    var isBearishContinuation = params.isCandleThree_Bullish
            && params.isCandleTwo_Bearish && params.candleTwo_Open > params.candleThree_Close && params.candleTwo_Close < params.candleThree_Open
            && params.isCandleOne_Bearish;
    var isBullishContinuation = params.isCandleThree_Bearish
            && params.isCandleTwo_Bullish && params.candleTwo_Open < params.candleThree_Close && params.candleTwo_Close > params.candleThree_Open
            && params.isCandleOne_Bullish;
    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
};

CDL.prototype.CDL3STARSSOUTH = function () {
    var params = CDLGETPARAMS(this.priceData);
    var candleThreeBodySize = Math.abs(params.candleThree_Close - params.candleThree_Open),
        candleTwoBodySize = Math.abs(params.candleTwo_Close - params.candleTwo_Open),
        candleOneBodySize = Math.abs(params.candleOne_Close - params.candleOne_Open);
    var candleThreeLowerShadow = Math.abs(params.candleThree_Low - Math.min(params.candleThree_Close, params.candleThree_Open));

    var candleOneObejct = this.CDLMARUBOZU(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);

    var isBullishContinuation = params.isCandleThree_Bearish && (candleThreeLowerShadow >= candleThreeBodySize) //A black candlestick with almost no upper shadow and a long lower shadow appears on the first day.
                && params.isCandleTwo_Bearish && (params.candleTwo_Low > params.candleThree_Low) && (params.candleTwo_Open < params.candleThree_Open) && (candleTwoBodySize < candleThreeBodySize) // The next day is another black candlestick closing below the previous day�s close and having an opening in the range of the previous day�s body. However, it has a higher low.
                && candleOneObejct.isBear && (params.candleOne_Low > params.candleTwo_Low) && (candleOneBodySize < candleTwoBodySize);//The last day is a small black Marubozu with a higher low
   
    //It's a bullish candlestick
    var isBearishContinuation = false;
    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
};

CDL.prototype.CDLABANDONEDBABY = function () {
     var params = CDLGETPARAMS(this.priceData);

    var dojiResponse_candleTwo = this.CDLDOJI(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close);

    var isBearishContinuation = params.isCandleThree_Bullish
                                && dojiResponse_candleTwo.isDoji && (params.candleTwo_Low > params.candleThree_High)
                                && params.isCandleOne_Bearish && (params.candleTwo_Low > params.candleOne_High);

    var isBullishContinuation = params.isCandleThree_Bearish
                                && dojiResponse_candleTwo.isDoji && (params.candleTwo_High < params.candleThree_Low)
                                && params.isCandleOne_Bullish && (params.candleTwo_High < params.candleOne_Low);

    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
}

CDL.prototype.CDLADVANCEBLOCK = function () {

    var params = CDLGETPARAMS(this.priceData);

    var candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
        candleThreeBody = Math.abs(params.candleThree_Open - params.candleThree_Close),
        candleTwoBody = Math.abs(params.candleTwo_Open - params.candleTwo_Close),
        candleThreeUpperShadow = Math.abs(params.candleThree_High - params.candleThree_Close),
        candleTwoUpperShadow = Math.abs(params.candleTwo_High - params.candleTwo_Close),
        candleOneUpperShadow = Math.abs(params.candleOne_High - params.candleOne_Close);

    //It's a bearish candlestick
    var isBullishContinuation = false;

    var isBearishContinuation = params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) //Three long white days occur, each with a higher close than the previous day
                                && params.isCandleTwo_Bullish && (candleTwoBody <= candleThreeBody) && (params.candleTwo_Close > params.candleThree_Close)
                                && (params.candleTwo_Open <= params.candleThree_Close) && (params.candleTwo_Open > params.candleThree_Open) //Each day opens within the body of the previous day 
                                && params.isCandleOne_Bullish && (candleOneBody <= candleTwoBody) && (params.candleOne_Close > params.candleTwo_Close)
                                && (params.candleOne_Open <= params.candleTwo_Close) && (params.candleOne_Open > params.candleTwo_Open) //Each day opens within the body of the previous day
                                && (candleTwoUpperShadow > candleThreeUpperShadow) && (candleOneUpperShadow > candleThreeUpperShadow); //The second and third days should also show long upper wicks

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLBELTHOLD = function () {

    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleThree_Bearish  //After a stretch of bearish candlestick
                                && params.isCandleTwo_Bearish //After a stretch of bearish candlestick
                                && params.isCandleOne_Bullish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))  //Long candle
                                && (params.candleOne_Open === params.candleOne_Low) && (params.candleOne_Open < params.candleTwo_Close);// a bullish or white candlestick forms. The opening price, which becomes the low for the day, is significantly lower then the closing price.

    var isBearishContinuation = params.isCandleThree_Bullish  //After a stretch of bullish candlestick
                                && params.isCandleTwo_Bullish //After a stretch of bullish candlestick
                                && params.isCandleOne_Bearish &&  (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) //Long candle
                                && (params.candleOne_Open === params.candleOne_High) && (params.candleOne_Open > params.candleTwo_Close);// a bearish or black candlestick forms. the opening price, which becomes the high for the day, is higher than the close of the previous day.

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLBREAKAWAY = function () {

    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 && params.candleFive_Index > 0) {
        var candleFiveBody = Math.abs(params.candleFive_Close - params.candleFive_Open);
        var shortCandleSize = candleFiveBody / 2;

        var isBullishContinuation = params.isCandleFive_Bearish && (this.indicators.isLongCandle(params.candleFive_Open, params.candleFive_High, params.candleFive_Low, params.candleFive_Close)) //long candle
                                  && params.isCandleFour_Bearish && (Math.abs(params.candleFour_Close - params.candleFour_Open) < shortCandleSize) && (params.candleFour_Open < params.candleFive_Close)
                                  && (Math.abs(params.candleThree_Close - params.candleThree_Open) < shortCandleSize) && (Math.min(params.candleThree_Close, params.candleThree_Open) < params.candleFour_Close)
                                  && (Math.abs(params.candleTwo_Close - params.candleTwo_Open) < shortCandleSize) && (Math.min(params.candleTwo_Close, params.candleTwo_Open) < Math.min(params.candleThree_Close, params.candleThree_Open))
                                  && params.isCandleOne_Bullish //The fifth day is a long blue day 
                                  && (params.candleOne_Open > (Math.min(params.candleTwo_Close, params.candleTwo_Open)))
                                  && (params.candleOne_Close > params.candleFour_Open) && (params.candleOne_Close < params.candleFive_Open);//closes inside the gap formed between the first two days..


        var isBearishContinuation = params.isCandleFive_Bullish
                                  && params.isCandleFour_Bullish && (Math.abs(params.candleFour_Close - params.candleFour_Open) < params.shortCandleSize) && (params.candleFour_Open > params.candleFive_Close)
                                  && (Math.abs(params.candleThree_Close - params.candleThree_Open) < shortCandleSize) && (Math.max(params.candleThree_Close, params.candleThree_Open) > params.candleFour_Close)
                                  && (Math.abs(params.candleTwo_Close - params.candleTwo_Open) < shortCandleSize) && (Math.max(params.candleTwo_Close, params.candleTwo_Open) > Math.max(params.candleThree_Close, params.candleThree_Open))
                                  && params.isCandleOne_Bearish //The fifth day is a long red day 
                                  && (params.candleOne_Open < (Math.max(params.candleTwo_Close, params.candleTwo_Open)))
                                  && (params.candleOne_Close < params.candleFour_Open) && (params.candleOne_Close > params.candleFive_Close);//that closes inside of the gap between the first and second candle

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLCLOSINGMARUBOZU = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBearishContinuation = params.isCandleOne_Bearish
                               && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))
                               && (params.candleOne_Low === params.candleOne_Close);

    var isBullishContinuation = params.isCandleOne_Bullish
                               && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))
                               && (params.candleOne_High === params.candleOne_Close);

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLCOUNTERATTACK = function () {

    var params = CDLGETPARAMS(this.priceData);

    var candleTwoBody = Math.abs(params.candleTwo_Close - params.candleTwo_Open);

    var isBullishContinuation = params.isCandleTwo_Bearish // bearish counterattack is a long black candle in an uptrend
                                && params.isCandleOne_Bullish  //followed by a long white candle.
                                && (params.candleOne_Close <= (params.candleTwo_Close + (candleTwoBody * 0.05)))
                                && (params.candleOne_Close >= (params.candleTwo_Close - (candleTwoBody * 0.05)));// Closing prices of both candles are at the same price level.

    var isBearishContinuation = params.isCandleTwo_Bullish // bullish counterattack is a long white candle in an uptrend level.
                                && params.isCandleOne_Bearish //followed by a long white candle.
                                && (params.candleOne_Close <= (params.candleTwo_Close + (candleTwoBody * 0.05)))
                                && (params.candleOne_Close >= (params.candleTwo_Close - (candleTwoBody * 0.05)));// Closing prices of both candles are at the same price level.

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLDARKCLOUDCOVER = function () {

    var params = CDLGETPARAMS(this.priceData);

    //It's a bearish candlestick
    var isBullishContinuation = false;

    var isBearishContinuation = params.isCandleTwo_Bullish
                                && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_Close) //Black candlestick must open above the previous close.
                                && (params.candleOne_Close < (params.candleTwo_Open + (Math.abs(params.candleTwo_Open - params.candleTwo_Close) / 2))) //closes below the middle of day 1 bullish candlestick.
                                && (params.candleOne_Close > params.candleTwo_Open);//close within the price range of the previous day

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLDOJISTAR = function () {

    var params = CDLGETPARAMS(this.priceData);

    var dojiResponse_candleOne = this.CDLDOJI(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);

    var isBearishContinuation = params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //The first day is long green day
                                && dojiResponse_candleOne.isBear && (params.candleOne_Close >= params.candleTwo_Close); //Second day is a doji that opens at the previous day close

    var isBullishContinuation = params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //The first day is long red day
                                && dojiResponse_candleOne.isBull && (params.candleOne_Close <= params.candleTwo_Close); //Second day is a doji that opens at the previous day close

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDL3WHITESOLDIERS = function() {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        isBullishContinuation = params.isCandleThree_Bullish && params.candleThree_Close >= params.candleFour_Close
            && this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)
            && params.isCandleTwo_Bullish && params.candleTwo_Open >= params.candleThree_Open
            && params.candleTwo_Open <= params.candleThree_Close && params.candleTwo_Close >= params.candleThree_Close
            && this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)
            && params.isCandleOne_Bullish && params.candleOne_Open >= params.candleTwo_Open
            && params.candleOne_Open <= params.candleTwo_Close && params.candleOne_Close >= params.candleTwo_Close
            && this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);

        //It's a bullish candlestick
        isBearishContinuation = false;
    }

    return {
        isBear : isBearishContinuation,
        isBull : isBullishContinuation
    };
};

CDL.prototype.CDLDRAGONFLYDOJI = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowWick = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        highWick = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close),
        isOpenCloseHighAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || (realBodySize < (candleBodySize * 0.1)))
        && ((params.candleOne_High === Math.max(params.candleOne_Open, params.candleOne_Close)) || (highWick < (candleBodySize * 0.1))),
        isLowerWickLong = (lowWick >= (candleBodySize * 0.60));

    var isBullishContinuation = params.isCandleTwo_Bearish //occurs at the bottom of downtrends.
                                && isOpenCloseHighAlmostSame //the open, high, and close are the same or about the same price
                                && isLowerWickLong;// The most important part of the Dragonfly Doji is the long lower shadow.

    var isBearishContinuation = params.isCandleTwo_Bullish //occurs at the top of uptrends
                                && isOpenCloseHighAlmostSame //the open, high, and close are the same or about the same price
                                && isLowerWickLong;// The most important part of the Dragonfly Doji is the long lower shadow.

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLENGULFING = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowWick = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        highWick = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close),
        isOpenCloseHighAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || (realBodySize < (candleBodySize * 0.1)))
        && ((params.candleOne_High === Math.max(params.candleOne_Open, params.candleOne_Close)) || (highWick < (candleBodySize * 0.1))),
        isLowerWickLong = (lowWick >= (candleBodySize * 0.60));

    var isBearishContinuation = params.isCandleTwo_Bullish && params.isCandleOne_Bearish && params.candleTwo_Close < params.candleOne_Open && params.candleTwo_Open > params.candleOne_Close;

    var isBullishContinuation = params.isCandleTwo_Bearish && params.isCandleOne_Bullish && params.candleTwo_Close > params.candleOne_Open && params.candleTwo_Open < params.candleOne_Close;

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLEVENINGDOJISTAR = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        var candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
            candleThreeBody = Math.abs(params.candleThree_Open - params.candleThree_Close),
            candleTwoBody = Math.abs(params.candleTwo_Low - params.candleTwo_High),
            iscandleTwoDoji = (params.candleTwo_Open === params.candleTwo_Close) || ((candleTwoBody * 0.10) >= Math.abs(params.candleTwo_Open - params.candleTwo_Close));

        //It's a bearish candlestick
        var isBullishContinuation = false;

        var isBearishContinuation = (params.candleThree_Close >= Math.max(params.candleFour_Close, params.candleFour_Open))  //occurs at the top of an uptrend.
                                    && params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))  //The first part of an Evening Star reversal pattern is a large bullish green candle.
                                    && iscandleTwoDoji && (Math.min(params.candleTwo_Open, params.candleTwo_Close) > params.candleThree_Close) //The second day begins with a gap up and it is quite small and can be bullish or bearish.
                                    && params.isCandleOne_Bearish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && (params.candleOne_Open < Math.min(params.candleTwo_Open, params.candleTwo_Close))//a large Bearish Candle with gap down.
                                    && (params.candleOne_Close > params.candleThree_Open) && (params.candleOne_Close < params.candleThree_Close); //closes well within the body of the first candle
    }

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLEVENINGSTAR = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        var candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close);
        var candleTwoBody = Math.abs(params.candleTwo_Open - params.candleTwo_Close);
        var candleTwoSize = Math.abs(params.candleTwo_Low - params.candleTwo_High);
        var candleThreeBody = Math.abs(params.candleThree_Open - params.candleThree_Close);

        var isBullishContinuation = false;

        //Evening Star is bearish only
        var isBearishContinuation = (params.candleThree_Close >= Math.max(params.candleFour_Close, params.candleFour_Open))  //occurs at the top of an uptrend.
                                    && params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))//The first part of an Evening Star reversal pattern is a large bullish green candle.
                                    && (candleTwoBody >= candleTwoSize * 0.10) && (Math.min(params.candleTwo_Open, params.candleTwo_Close) > params.candleThree_Close) //The second day begins with a gap up and it is quite small and can be bullish or bearish.
                                    && params.isCandleOne_Bearish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && (params.candleOne_Open < Math.min(params.candleTwo_Open, params.candleTwo_Close))//a large Bearish Candle with gap down.
                                    && (params.candleOne_Close > params.candleThree_Open) && (params.candleOne_Close < params.candleThree_Close);
    }

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
};

CDL.prototype.CDLGAPSIDESIDEWHITE = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleThree_Bullish  //the first candlestick is upward 
                                && params.isCandleTwo_Bullish && (params.candleTwo_Open > params.candleThree_Close) //followed by another upward that opens above  the first (gap up), 
                                && params.isCandleOne_Bullish && (params.candleOne_Open > params.candleThree_Close) && (params.candleOne_Open < params.candleTwo_Close)// followed by a third upward candlestick that opens below the close of the second (gap down)
                                && (params.candleOne_Close <= (params.candleTwo_Close + (Math.abs(params.candleTwo_Close - params.candleTwo_Open) * 0.10)));

    var isBearishContinuation = params.isCandleThree_Bearish  //the first candlestick is downward
                                && params.isCandleTwo_Bullish && (params.candleTwo_Close < params.candleThree_Close)//followed by an upward candlestick that opens below the  first one (gap down),
                                && params.isCandleOne_Bullish && (params.candleOne_Close < params.candleThree_Close) && (params.candleOne_Open < params.candleTwo_Close)// followed by an upward candlestick that opens below the close of the second one
                                && (params.candleOne_Close <= (params.candleTwo_Close + (Math.abs(params.candleTwo_Close - params.candleTwo_Open) * 0.10)));

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLGRAVESTONEDOJI = function () {
    var params = CDLGETPARAMS(this.priceData);

    var highWick = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        isOpenCloseLowAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || ((candleBodySize * 0.05) >= Math.abs(params.candleOne_Open - params.candleOne_Close)))
        && (params.candleOne_Low === Math.min(params.candleOne_Open, params.candleOne_Close)) || ((candleBodySize * 0.05) >= Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close))),
        isUpperShadowLong = (highWick >= (candleBodySize * 0.80));

    var isBullishContinuation = params.isCandleTwo_Bearish //occurs at the top of downtrend
                                && isOpenCloseLowAlmostSame //the open, high, and close are the same or about the same price
                                && isUpperShadowLong;// The most important part of the Graveston Doji is the long upper shadow..

    var isBearishContinuation = params.isCandleTwo_Bullish //occurs at the top of uptrends
                                && isOpenCloseLowAlmostSame //the open, high, and close are the same or about the same price
                                && isUpperShadowLong;// The most important part of the Graveston Doji is the long upper shadow..

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHAMMER = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleOneUpperShadow = Math.abs(Math.max(params.candleOne_Open, params.candleOne_Close) - params.candleOne_High),
        candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        candleOneLowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Close, params.candleOne_Open)),
        isOpenCloseHighAlmostSame = (candleOneBody < (candleBodySize * 0.40))
        && ((params.candleOne_High === Math.max(params.candleOne_Open, params.candleOne_Close)) || (candleOneUpperShadow < (candleBodySize * 0.10)));

    var isBullishContinuation = params.isCandleTwo_Bearish && (params.candleTwo_Open < Math.min(params.candleThree_Close, params.candleThree_Open)) //a downward trend indicating a bullish reversal, it is a hammer
                                && isOpenCloseHighAlmostSame  //the open, high, and close are roughly the same price. means it has a small body.
                                && (candleOneLowerShadow >= (2.0 * candleOneBody)) && (params.candleOne_Close < params.candleTwo_Close); //there is a long lower shadow, twice the length as the real body.

    //It's a bullish candlestick
    var isBearishContinuation = false;

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHANGINGMAN = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleOneUpperShadow = Math.abs(Math.max(params.candleOne_Open, params.candleOne_Close) - params.candleOne_High),
        candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        candleOneLowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Close, params.candleOne_Open)),
        isOpenCloseHighAlmostSame = (candleOneBody < (candleBodySize * 0.40))
        && ((params.candleOne_High === Math.max(params.candleOne_Open, params.candleOne_Close)) || (candleOneUpperShadow < (candleBodySize * 0.10)));

    var isBearishContinuation = params.isCandleTwo_Bullish && (params.candleTwo_Open > Math.max(params.candleThree_Close, params.candleThree_Open)) //a downward trend indicating a bullish reversal, it is a hammer
                              && isOpenCloseHighAlmostSame //the open, high, and close are roughly the same price. means it has a small body.
                              && (candleOneLowerShadow >= (2.0 * candleOneBody) && (params.candleOne_Close > params.candleTwo_Close)); //there is a long lower shadow, twice the length as the real body.

    //It's a bearish candlestick
    var isBullishContinuation = false;

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHARAMI = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))//the first candlestick is upward
                                && params.isCandleOne_Bullish && (params.candleOne_Open > params.candleTwo_Close) && (params.candleOne_Close < params.candleTwo_Open)// followed by a smaller candlestick whose body is located within the vertical range of the larger body
                                && (Math.abs(params.candleOne_Open - params.candleOne_Close) < (Math.abs(params.candleTwo_Open - params.candleTwo_Close) * 0.60)); //Must be smaller than prevoius day

    var isBearishContinuation = params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))// a large bullish green candle on Day 1
                               && params.isCandleOne_Bearish && (params.candleOne_Open < params.candleTwo_Close) && (params.candleOne_Close > params.candleTwo_Open)// followed by a smaller candlestick whose body is located within the vertical range of the larger body
                               && (Math.abs(params.candleOne_Open - params.candleOne_Close) < (Math.abs(params.candleTwo_Open - params.candleTwo_Close) * 0.60));//Must be smaller than prevoius day

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHARAMICROSS = function () {
    var params = CDLGETPARAMS(this.priceData);

    var dojiResponse_candleOne = this.CDLDOJI(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);

    var isBullishContinuation = params.isCandleTwo_Bearish //the first candlestick is upward
                                && dojiResponse_candleOne.isBull && (Math.min(params.candleOne_Close, params.candleOne_Open) > params.candleTwo_Close) && (Math.max(params.candleOne_Close, params.candleOne_Open) < params.candleTwo_Open); //followed by a doji that is located within the top and bottom of the candlestick's body. 

    var isBearishContinuation = params.isCandleTwo_Bullish // a large bullish green candle on Day 1
                                && dojiResponse_candleOne.isBear && (Math.min(params.candleOne_Close, params.candleOne_Open) > params.candleTwo_Open) && (Math.max(params.candleOne_Close, params.candleOne_Open) < params.candleTwo_Close); //followed by a doji that is located within the top and bottom of the candlestick's body. 

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHOMINGPIGEON = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleOneBody = Math.abs(params.candleOne_Close - params.candleOne_Open);

    var isBullishContinuation = params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))// First candle is a long black candle.
                                && params.isCandleOne_Bearish 
                                && (params.candleOne_Low > params.candleTwo_Low) && (params.candleOne_Close > params.candleTwo_Close) // Second candle is an inside bar, which is also a black candle. Second candle closes inside the body of the first candle.
                                && (params.candleOne_High < params.candleTwo_High) && (params.candleOne_Open < params.candleTwo_Open);
    //It's a bullish candlestick
    var isBearishContinuation = false;

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHIKKAKE = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 && params.candleFive_Index > 0) {
        var isBullishContinuation = Math.max(params.candleFive_Close, params.candleFive_Open) > Math.max(params.candleFour_Close, params.candleFour_Open)
                                   && Math.min(params.candleFive_Close, params.candleFive_Open) < Math.min(params.candleFour_Close, params.candleFour_Open)
                                   && Math.max(params.candleFive_Close, params.candleFive_Open) > Math.max(params.candleThree_Close, params.candleThree_Open)
                                   && Math.max(params.candleFive_Close, params.candleFive_Open) > Math.max(params.candleTwo_Close, params.candleTwo_Open)
                                   && params.isCandleOne_Bullish
                                   && (params.candleOne_Close > Math.max(params.candleFive_Close, params.candleFive_Open));// reaches above the range of the three preceding ,

        var isBearishContinuation = Math.max(params.candleFive_Close, params.candleFive_Open) > Math.max(params.candleFour_Close, params.candleFour_Open)
                                  && Math.min(params.candleFive_Close, params.candleFive_Open) < Math.min(params.candleFour_Close, params.candleFour_Open)
                                  && Math.min(params.candleFive_Close, params.candleFive_Open) < Math.min(params.candleThree_Close, params.candleThree_Open)
                                  && Math.min(params.candleFive_Close, params.candleFive_Open) < Math.min(params.candleTwo_Close, params.candleTwo_Open)
                                  && params.isCandleOne_Bearish
                                  && (params.candleOne_Close < Math.min(params.candleFive_Close, params.candleFive_Open));

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLIDENTICAL3CROWS = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 ) {
        var candleThreeBodySize = Math.abs(params.candleThree_Close - params.candleThree_Open),
             candleTwoBodySize = Math.abs(params.candleTwo_Close - params.candleTwo_Open),
             candleOneBodySize = Math.abs(params.candleOne_Close - params.candleOne_Open);

        //It''s a bearish candlestick
        var isBullishContinuation = false;

        var isBearishContinuation = params.isCandleFour_Bullish
                                 && params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))
				                 && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) && (params.candleTwo_Open === params.candleThree_Close || (Math.abs(params.candleThree_Close - params.candleTwo_Open) < (candleThreeBodySize * .10))) && (params.candleTwo_Close < params.candleThree_Close) //Three consecutive long red days with lower closes each day
					             && params.isCandleOne_Bearish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && (params.candleOne_Open === params.candleTwo_Close || (Math.abs(params.candleTwo_Close - params.candleOne_Open) < (candleTwoBodySize * .10))) && (params.candleOne_Close < params.candleTwo_Close);  //and Each day opens at or near the previous day's close.

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLINNECK = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleTwoBodySize = Math.abs(params.candleTwo_Close - params.candleTwo_Open);

    var isBullishContinuation = params.isCandleThree_Bullish //After an uptrend
                                && params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //1st day is a long blue day.
                                && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_High)  //2nd day is a red day which opens above the high of the 1st day
                                && (params.candleOne_Close < params.candleTwo_Close) && (params.candleOne_Close > (params.candleTwo_Close - (candleTwoBodySize * 0.10)));//2nd day closes barely into the body of the 1st day,near 1st day close.

    var isBearishContinuation = params.isCandleThree_Bearish //After a downtrend
                                && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //1st day is a long red day.
                                && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Low)  //2nd day is a white day which opens below the low of the 1st day
                                && (params.candleOne_Close > params.candleTwo_Close) && (params.candleOne_Close < (params.candleTwo_Close + (candleTwoBodySize * 0.10)));//2nd day closes barely into the body of the 1st day,near 1st day close.

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLINVERTEDHAMMER = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleOneUpperShadow = Math.abs(Math.max(params.candleOne_Open, params.candleOne_Close) - params.candleOne_High),
        candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        candleOneLowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Close, params.candleOne_Open)),
        isOpenCloseLowAlmostSame = (candleOneBody < (candleBodySize * 0.40))
        && ((params.candleOne_Low === Math.min(params.candleOne_Open, params.candleOne_Close)) || (candleOneLowerShadow < (candleBodySize * 0.10)));

    var isBullishContinuation = (Math.min(params.candleTwo_Close, params.candleTwo_Open) < (Math.min(params.candleThree_Open, params.candleThree_Close)))
                                && (Math.min(params.candleOne_Close, params.candleOne_Open) < Math.min(params.candleTwo_Close, params.candleTwo_Open))  //a downward trend indicating a bullish reversal, it is a inverted hammer
                                && isOpenCloseLowAlmostSame //the open, low, and close are roughly the same price. means it has a small body.
                                && (candleOneUpperShadow >= (2.0 * candleOneBody)); //there is a long upper shadow, which should be at least twice the length of the real body.
    //It's a bullish candlestick
    var isBearishContinuation = false;

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLKICKING = function () {
    var params = CDLGETPARAMS(this.priceData);
    var candleOneObejct = this.CDLMARUBOZU(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);
    var candleTwoObejct = this.CDLMARUBOZU(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close);

    var isBullishContinuation = candleTwoObejct.isBear  // a black or filled candlestick without any wicks (shadows)
                               && candleOneObejct.isBull //followed by a gap higher with a white or hollow candlestick that is also without wicks.
                               && (params.candleOne_Close > params.candleTwo_Open); //Gap up

    var isBearishContinuation = candleTwoObejct.isBull  // a black or filled candlestick without any wicks (shadows)
                               && candleOneObejct.isBear //followed by a gap higher with a white or hollow candlestick that is also without wicks.
                               && (params.candleOne_Close < params.candleTwo_Open); //Gap down

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLLADDERBOTTOM = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 && params.candleFive_Index > 0) {
        var isBullishContinuation = params.isCandleFive_Bearish
                                    && params.isCandleFour_Bearish && params.candleFour_Open > params.candleFive_Close && params.candleFour_Close < params.candleFive_Close && params.candleFour_Open < params.candleFive_Open// 1st three days are red days with lower opens and closes each day.
                                    && params.isCandleThree_Bearish && params.candleThree_Open > params.candleFour_Close && params.candleThree_Close < params.candleFour_Close && params.candleThree_Open < params.candleFour_Open// 1st three days are red days with lower opens and closes each day.
                                    && params.isCandleTwo_Bearish && params.candleTwo_High > params.candleThree_Close && params.candleTwo_High > params.candleTwo_Open && params.candleTwo_Close < params.candleThree_Close && params.candleTwo_Open < params.candleThree_Open // 4th day is a red day with an upper shadow.
                                    && params.isCandleOne_Bullish && params.candleOne_Open > params.candleTwo_Open; //The last day is white that opens above the body of the 4th day.

        //It's a bullish candlestick
        var isBearishContinuation = false;

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLKICKINGBYLENGTH = function () {
    var params = CDLGETPARAMS(this.priceData);
    var candleOneObejct = this.CDLMARUBOZU(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);
    var candleTwoObejct = this.CDLMARUBOZU(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close);

    var isBullishContinuation = candleTwoObejct.isBear && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) // a black or filled candlestick without any wicks (shadows)
                              && candleOneObejct.isBull && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))//followed by a gap higher with a white or hollow candlestick that is also without wicks.
                              && (params.candleOne_Close > params.candleTwo_Open); //Gap up

    var isBearishContinuation = candleTwoObejct.isBull && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) // a black or filled candlestick without any wicks (shadows)
                               && candleOneObejct.isBear && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) //followed by a gap higher with a white or hollow candlestick that is also without wicks.
                               && (params.candleOne_Close < params.candleTwo_Open); //Gap down

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLLONGLEGGEDDOJI = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        upperShadow = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close),
        isOpenCloseAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || (realBodySize < (candleBodySize * 0.10))),
        isLowerShadowLong = (lowerShadow >= (candleBodySize * 0.40)) && (lowerShadow <= (candleBodySize * 0.80)),
        isUpperShadowLong = (upperShadow >= (candleBodySize * 0.40)) && (upperShadow <= (candleBodySize * 0.80));

    var isBullishContinuation = params.isCandleTwo_Bearish//occurs at the bottom of downtrends.
                                && isOpenCloseAlmostSame //vary small  body 
                                && isUpperShadowLong //long and almost same shadows 
                                && isLowerShadowLong;// long and almost same shadows

    var isBearishContinuation = params.isCandleTwo_Bullish //occurs at the top of uptrends\
                                && isOpenCloseAlmostSame //vary small body 
                                && isUpperShadowLong //long and almost same shadows
                                && isLowerShadowLong;// long and almost same shadows.

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLLONGLINE = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        upperShadow = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Close - params.candleOne_Open),
        isLowerShadowShort = (lowerShadow === 0) || (lowerShadow < (candleBodySize * 0.10)),
        isUpperShadowShort = (upperShadow === 0) || (upperShadow < (candleBodySize * 0.10));

    var isBullishContinuation = params.isCandleOne_Bullish
                                && this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)
                                && isLowerShadowShort && isUpperShadowShort;

    var isBearishContinuation = params.isCandleOne_Bearish
                                && this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)
                                && isLowerShadowShort && isUpperShadowShort;

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLMARUBOZU = function (candleOne_Open, candleOne_High, candleOne_Low, candleOne_Close) {
    var params = CDLGETPARAMS(this.priceData);

    var lowerShadow = Math.abs(candleOne_Low - Math.min(candleOne_Open, candleOne_Close)),
        upperShadow = Math.abs(candleOne_High - Math.max(candleOne_Open, candleOne_Close)),
        candleBodySize = Math.abs(candleOne_Low - candleOne_High),
        realBodySize = Math.abs(candleOne_Close - candleOne_Open),
        isLowerShadowShort = (lowerShadow === 0) || (lowerShadow <= (candleBodySize * 0.05)),
        isUpperShadowShort = (upperShadow === 0) || (upperShadow <= (candleBodySize * 0.05));
    var isCandleOne_Bearish = candleOne_Close > candleOne_Open,
        isCandleOne_Bullish = candleOne_Close < candleOne_Open;

    isBearishContinuation = isCandleOne_Bearish
                          && this.indicators.isLongCandle(candleOne_Open, candleOne_High, candleOne_Low, candleOne_Close)
                          && (isUpperShadowShort && isLowerShadowShort);
    isBullishContinuation = isCandleOne_Bullish
                          && this.indicators.isLongCandle(candleOne_Open, candleOne_High, candleOne_Low, candleOne_Close)
                          && isUpperShadowShort && isLowerShadowShort;

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLMATCHINGLOW = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleTwo_Bearish && (params.candleTwo_Open > params.candleOne_Open)  // The first candle has a tall body
                               && params.isCandleOne_Bearish && (params.candleOne_Close === params.candleTwo_Close); //The second day follows with another black candlestick whose closing price is exactly equal to the closing price of the first day.

    //It's a bullish candlestick
    var isBearishContinuation = false;

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLMATHOLD = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 && params.candleFive_Index > 0) {
       var isBullishContinuation = params.isCandleFive_Bullish && (this.indicators.isLongCandle(params.candleFive_Open, params.candleFive_High, params.candleFive_Low, params.candleFive_Close))  //The first day is a long white day
                                    && params.isCandleFour_Bearish && (params.candleFour_Close > params.candleFive_Close) //The second day gaps up and is a black day
                                    && params.isCandleThree_Bearish && (params.candleThree_Close < params.candleFour_Close)//The second, third, and fourth days have small real bodies and follow a brief downtrend pattern, but stay within the range of the first day 
                                    && params.isCandleTwo_Bearish && (params.candleTwo_Close < params.candleThree_Close) && (params.candleTwo_Close > params.candleFive_Open) //  stay within the range of the first day 
                                    && params.isCandleOne_Bullish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))
                                    && (params.candleOne_Close > params.candleFour_Open);// The fifth day is a long white day that closes above the trading ranges of the previous four days

        var isBearishContinuation = params.isCandleFive_Bearish && (this.indicators.isLongCandle(params.candleFive_Open, params.candleFive_High, params.candleFive_Low, params.candleFive_Close)) //The first day is a long red day
                                    && params.isCandleFour_Bullish && (params.candleFour_Close < params.candleFive_Close)//The second day gaps up and is a black day
                                    && params.isCandleThree_Bullish && (params.candleThree_Close > params.candleFour_Close)//The second, third, and fourth days have small real bodies and follow a brief downtrend pattern, but stay within the range of the first day 
                                    && params.isCandleTwo_Bullish && (params.candleTwo_Close > params.candleThree_Close) && (params.candleTwo_Close < params.candleFive_Open) //  stay within the range of the first day 
                                    && params.isCandleOne_Bearish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))
                                    && (params.candleOne_Close < params.candleFour_Open);// The fifth day is a long white day that closes bellow  the trading ranges of the previous four days

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLMORNINGDOJISTAR = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        var candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
            candleThreeBody = Math.abs(params.candleThree_Open - params.candleThree_Close),
            candleTwoBody = Math.abs(params.candleTwo_Low - params.candleTwo_High),
            iscandleTwoDoji = params.candleTwo_Open === params.candleTwo_Close || ((candleTwoBody * 0.10) >= Math.abs(params.candleTwo_Open - params.candleTwo_Close));

        var isBullishContinuation = (params.candleThree_Close < Math.min(params.candleFour_Close, params.candleFour_Open))  //occurs within a defined downtrend.
                                    && params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))  //The first part of an Evening Star reversal pattern is a large bullish green candle.
                                    && iscandleTwoDoji && (Math.max(params.candleTwo_Open, params.candleTwo_Close) < params.candleThree_Close) //The second day begins with a gap down and it is quite small and can be bullish or bearish.
                                    && params.isCandleOne_Bullish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && (params.candleOne_Open > Math.max(params.candleTwo_Open, params.candleTwo_Close))//a large Bullish Candle with gap up.
                                    && (params.candleOne_Close < params.candleThree_Open) && (params.candleOne_Close > params.candleThree_Close); //closes well within the body of the first candle

        //It's a bullish candlestick
        var isBearishContinuation = false;
    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLMORNINGSTAR = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        var candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close);
        var candleTwoBody = Math.abs(params.candleTwo_Open - params.candleTwo_Close);
        var candleThreeBody = Math.abs(params.candleThree_Open - params.candleThree_Close);

        var isBullishContinuation = (params.candleThree_Close < Math.min(params.candleFour_Close, params.candleFour_Open)) //its a bullish reversal pattern, usually occuring at the bottom of a downtrend. 
                                    && params.isCandleThree_Bearish && (candleThreeBody > (candleTwoBody * 3)) //The first part of an Evening Star reversal pattern is a large bullish green candle.
                                    && (candleTwoBody < (candleThreeBody / 3)) && (Math.max(params.candleTwo_Open, params.candleTwo_Close) < params.candleThree_Close) //The second day begins with a gap down and it is quite small and can be bullish or bearish.
                                    && params.isCandleOne_Bullish && (candleOneBody > candleTwoBody * 3) && (params.candleOne_Open > Math.max(params.candleTwo_Open, params.candleTwo_Close))//a large Bearish Candle than opens above the middle candle  and closes near the center of the first bar's body
                                    && (params.candleOne_Close < params.candleThree_Open);

        //It's a bullish only
        var isBearishContinuation = false;
    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLONNECK = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleTwoBodySize = Math.abs(params.candleTwo_Close - params.candleTwo_Open);

    var isBullishContinuation = params.isCandleThree_Bullish //After an uptrend
                                && params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //1st day is a long blue day.
                                && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_High)  //2nd day is a red day which opens above the high of the 1st day
                                && (params.candleOne_Close >= params.candleTwo_High) && (params.candleOne_Close <= (params.candleTwo_High + (candleTwoBodySize * 0.10)));//The closing price of the black candle is at or near the high of the white candle

    var isBearishContinuation = params.isCandleThree_Bearish //After a downtrend
                                && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //1st day is a long red day.
                                && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Low)  //2nd day is a white day which opens below the low of the 1st day
                                && (params.candleOne_Close <= params.candleTwo_Low) && (params.candleOne_Close >= (params.candleTwo_Low - (candleTwoBodySize * 0.10)));//The closing price of the white candle is at or near the low of the black candle


    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLPIERCING = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleTwo_Bearish
                                && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Close) //white candlestick must open below the previous close.
                                && (params.candleOne_Close > (Math.abs(params.candleTwo_Open + params.candleTwo_Close) / 2))//close above the midpoint of the black candlestick's body.
                                && (params.candleOne_Close < params.candleTwo_Open);//close within the price range of the previous day
    //It's a bullish candlestick
    var isBearishContinuation = false;


    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLRICKSHAWMAN = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        upperShadow = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close),
        isOpenCloseAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || (realBodySize < (candleBodySize * 0.10))),
        isLowerShadowLong = (lowerShadow >= (candleBodySize * 0.40)) && (lowerShadow <= (candleBodySize * 0.80)),
        isUpperShadowLong = (upperShadow >= (candleBodySize * 0.40)) && (upperShadow <= (candleBodySize * 0.80));

    var isBullishContinuation = params.isCandleTwo_Bearish//occurs at the bottom of downtrends.
                                && isOpenCloseAlmostSame //vary small  body 
                                && isUpperShadowLong //long and almost same shadows 
                                && isLowerShadowLong;// long and almost same shadows

    var isBearishContinuation = params.isCandleTwo_Bullish //occurs at the top of uptrends\
                                && isOpenCloseAlmostSame //vary small body 
                                && isUpperShadowLong //long and almost same shadows
                                && isLowerShadowLong;// long and almost same shadows.

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLRISEFALL3METHODS = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0 && params.candleFive_Index > 0) {
        var isBullishContinuation = params.isCandleFive_Bullish && (this.indicators.isLongCandle(params.candleFive_Open, params.candleFive_High, params.candleFive_Low, params.candleFive_Close)) //The first candlestick in this pattern is a light bullish candlestick with a large real body
                                    && params.candleFour_Low > params.candleFive_Low && params.candleFour_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.candleThree_Low > params.candleFive_Low && params.candleThree_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.candleTwo_Low > params.candleFive_Low && params.candleTwo_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.isCandleOne_Bullish && params.candleOne_Open > params.candleTwo_Close && params.candleOne_Close > params.candleFive_Close;//he last candlestick that completes the pattern should open higher than the close of its preceding candlestick and should close above the close of the first candlestick.

        var isBearishContinuation = params.isCandleFive_Bearish && (this.indicators.isLongCandle(params.candleFive_Open, params.candleFive_High, params.candleFive_Low, params.candleFive_Close))
                                    && params.candleFour_Low > params.candleFive_Low && params.candleFour_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.candleThree_Low > params.candleFive_Low && params.candleThree_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.candleTwo_Low > params.candleFive_Low && params.candleTwo_High < params.candleFive_High // it should be within the high and low of the first candlestick. 
                                    && params.isCandleOne_Bearish && params.candleOne_Open < params.candleTwo_Close && params.candleOne_Close < params.candleFive_Close;//The last candlestick that completes the pattern should below the close of its preceding candlestick and should close lower that the close of the first candlestick.

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLSEPARATINGLINES = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = (params.candleOne_Open > Math.max(params.candleThree_Open, params.candleThree_Close)) //After an uptrend
                               && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) // 1st day is a long red day
                               && params.isCandleOne_Bullish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))// 2nd day is a long white day
                               && (params.candleOne_Open === params.candleTwo_Open); //2nd day is a white day that opens at the opening price of the 1st day.


    var isBearishContinuation = (params.candleOne_Open < Math.min(params.candleThree_Open, params.candleThree_Close)) //After an downtrend
                               && params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))  // 1st day is a long white day
                               && params.isCandleOne_Bearish && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close))// 2nd day is a long red day
                               && (params.candleOne_Open === params.candleTwo_Open); //2nd day is a red day that opens at the opening price of the 1st day.


    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLSHOOTINGSTAR = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleOneUpperShadow = Math.abs(Math.max(params.candleOne_Open, params.candleOne_Close) - params.candleOne_High),
        candleOneBody = Math.abs(params.candleOne_Open - params.candleOne_Close),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        candleOneLowerShadow = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Close, params.candleOne_Open)),
        isOpenCloseLowAlmostSame = (candleOneBody < (candleBodySize * 0.40))
        && ((params.candleOne_Low === Math.min(params.candleOne_Open, params.candleOne_Close)) || (candleOneLowerShadow < (candleBodySize * 0.10)));

    var isBearishContinuation = Math.max(params.candleTwo_Close, params.candleTwo_Open) > (Math.max(params.candleThree_Open, params.candleThree_Close))
                               && (Math.max(params.candleOne_Close, params.candleOne_Open) > Math.max(params.candleTwo_Close, params.candleTwo_Open))
                               && isOpenCloseLowAlmostSame //the open, low, and close are roughly the same price. means it has a small body.
                               && (candleOneUpperShadow >= (2.0 * candleOneBody)); //there is a long upper shadow, which should be at least twice the length of the real body.

    //It's a bearish candlestick
    var isBullishContinuation = false;

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLSPINNINGTOP = function () {
    var params = CDLGETPARAMS(this.priceData);

    var upperShadow = params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close),
        lowerShadow = Math.min(params.candleOne_Open, params.candleOne_Close) - params.candleOne_Low,
        candleBodySize = Math.abs(params.candleOne_High - params.candleOne_Low),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close);


    var isBullishContinuation = params.isCandleTwo_Bearish && (params.candleTwo_Close < (Math.min(params.candleThree_Open, params.candleThree_Close)))
                              && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Close)
                              && (realBodySize <= (candleBodySize * 0.30)) //It is not too different to a Doji in structure, but rather than a flat body it has a small body between an open and close price
                              && (upperShadow > realBodySize) && (upperShadow < (candleBodySize * 0.50)) // The spinning top is composed of a small body with small upper and lower shadows.
                              && (lowerShadow > realBodySize) && (lowerShadow < (candleBodySize * 0.50));


    var isBearishContinuation = params.isCandleTwo_Bullish && (params.candleTwo_Close > (Math.max(params.candleThree_Open, params.candleThree_Close)))
                              && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_Close)
                              && (realBodySize <= (candleBodySize * 0.30)) //It is not too different to a Doji in structure, but rather than a flat body it has a small body between an open and close price
                              && (upperShadow > realBodySize) && (upperShadow < (candleBodySize * 0.50)) // The spinning top is composed of a small body with small upper and lower shadows.
                              && (lowerShadow > realBodySize) && (lowerShadow < (candleBodySize * 0.50));

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLSTALLEDPATTERN = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleThreeBodySize = Math.abs(params.candleThree_Close - params.candleThree_Open),
        candleTwoBodySize = Math.abs(params.candleTwo_Close - params.candleTwo_Open),
        candleOneBodySize = Math.abs(params.candleOne_Close - params.candleOne_Open);


    var isBullishContinuation = params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))// three candlesticks in a downtrend
                               && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) && (params.candleTwo_Open <= params.candleThree_Open) //The second candlestick must open close to the close of the previous day. 
                               && params.isCandleOne_Bearish && (params.candleOne_Open < params.candleTwo_Close)   //must open close to the close of the previous day.
                               //&& (candleOneBodySize < candleMediumHeight * 0.60); //the last candlestick must be short

    var isBearishContinuation = params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) // three candlesticks in a downtrend
                               && params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) && (params.candleTwo_Open >= params.candleThree_Open) //The second candlestick must open close to the close of the previous day. 
                               && params.isCandleOne_Bullish && (params.candleOne_Open > params.candleTwo_Close)   //must open close to the close of the previous day.
                               //&& (candleOneBodySize < candleMediumHeight * 0.60); //the last candlestick must be short

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLSTICKSANDWICH = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

    if (params.candleFour_Index >= 0) {
        var candleThreebodySize = Math.abs(params.candleThree_Close - params.candleThree_Open);
        var isCanldeOneCloseSameAsCandleThreeClose = (params.candleOne_Close === params.candleThree_Close)
                                          || (params.candleOne_Close <= (params.candleThree_Close + (candleThreebodySize * 0.05)))
                                          || (params.candleOne_Close >= (params.candleThree_Close - (candleThreebodySize * 0.05)));

        var isBullishContinuation = params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) && (params.candleThree_Close < (Math.min(params.candleFour_Close, params.candleFour_Open))) //We see a black candlestick on the first day after a downtrend
                                    && params.isCandleTwo_Bullish && (params.candleTwo_Close > params.candleThree_Open) && (params.candleTwo_Open > params.candleThree_Close) && (params.candleTwo_Open < params.candleThree_Open) //The second candlestick is a white (green) candlestick that gaps up from the previous close and closes above the previous day's open
                                    && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_Close) && (params.candleOne_Close < params.candleTwo_Open) //both of which will have a larger trading range than the middle candlestick.
                                    && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && isCanldeOneCloseSameAsCandleThreeClose;//The third day is a black day that closes at or near the close of the first day.

        var isBearishContinuation = params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) && (params.candleThree_Close > (Math.max(params.candleFour_Close, params.candleFour_Open))) //We see a white candlestick on the first day after an uptrend
                                    && params.isCandleTwo_Bearish && (params.candleTwo_Close < params.candleThree_Open) && (params.candleTwo_Open < params.candleThree_Close) && (params.candleTwo_Open > params.candleThree_Open)//The second candlestick is a black candlestick that gaps down from the previous close and closes bellow the previous day's open
                                    && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Close) && (params.candleOne_Close > params.candleTwo_Open) //both of which will have a larger trading range than the middle candlestick.
                                    && (this.indicators.isLongCandle(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close)) && isCanldeOneCloseSameAsCandleThreeClose;//The third day is a black day that closes at or near the close of the first day.

    }
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLTAKURI = function () {
    var params = CDLGETPARAMS(this.priceData);

    var lowWick = Math.abs(params.candleOne_Low - Math.min(params.candleOne_Open, params.candleOne_Close)),
        highWick = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close)),
        candleBodySize = Math.abs(params.candleOne_Low - params.candleOne_High),
        realBodySize = Math.abs(params.candleOne_Open - params.candleOne_Close),
        isOpenCloseHighAlmostSame = ((params.candleOne_Open === params.candleOne_Close) || (realBodySize < (candleBodySize * 0.20)))
        && ((params.candleOne_High === Math.max(params.candleOne_Open, params.candleOne_Close)) || (highWick < (candleBodySize * 0.20))),
        isLowerShadowLong = (lowWick >= (candleBodySize * 0.80));

    var isBullishContinuation = params.isCandleTwo_Bearish //occurs at the bottom of downtrends.
                                && isOpenCloseHighAlmostSame //the open, high, and close are the same or about the same price
                                && isLowerShadowLong;// with a Lower Shadow that is long at least three times the Real Body of the Candle; 

    var isBearishContinuation = params.isCandleTwo_Bullish //occurs at the top of uptrends
                                && isOpenCloseHighAlmostSame //the open, high, and close are the same or about the same price
                                && isLowerShadowLong;// with a Lower Shadow that is long at least three times the Real Body of the Candle; 

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLTASUKIGAP = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleThree_Bullish
                                && params.isCandleTwo_Bullish && params.candleTwo_Open > params.candleThree_Close //gaps above 1st day
                                && params.isCandleOne_Bearish && params.candleOne_Open > params.candleTwo_Open && params.candleOne_Open < params.candleTwo_Close //open inside the red 2day candle's real body.
                                && params.candleOne_Close < params.candleTwo_Open && params.candleOne_Close > params.candleThree_Close;//closes within the gap between the first two bars. 

    var isBearishContinuation = params.isCandleThree_Bearish
                                && params.isCandleTwo_Bearish && params.candleTwo_Open < params.candleThree_Close //gaps below 1st day
                                && params.isCandleOne_Bullish && params.candleOne_Open > params.candleTwo_Close && params.candleOne_Open < params.candleTwo_Open //open inside the red candle's real body.
                                && params.candleOne_Close < params.candleThree_Close && params.candleOne_Close > params.candleTwo_Open;//closes within the gap between the first two bars.

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLTHRUSTING = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBearishContinuation = params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //day-one of the pattern is a long red candle continuing the trend
                                && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Close) //Day-two is a blue day
                                && params.candleOne_Close <= (params.candleTwo_Close + (Math.abs(params.candleTwo_Open - params.candleTwo_Close) / 2)) // closes into the body (below midpoint) of the previous day
                                && (params.candleOne_Close >= params.candleTwo_Close);

    var isBullishContinuation = params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))////day-one of the pattern is a long blue candle
                                && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_Close) //Day-two is a red day
                                && params.candleOne_Close >= (params.candleTwo_Close - (Math.abs(params.candleTwo_Open - params.candleTwo_Close) / 2)) // closes into the body (above midpoint) of the previous day
                                && (params.candleOne_Close <= params.candleTwo_Close);

    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLTRISTAR = function () {
    var params = CDLGETPARAMS(this.priceData);

    var candleThreeDoji = this.CDLDOJI(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close);

    var candleTwoDoji = this.CDLDOJI(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close);

    var candleOneDoji = this.CDLDOJI(params.candleOne_Open, params.candleOne_High, params.candleOne_Low, params.candleOne_Close);

    var isBullishContinuation = candleThreeDoji.isDoji
                                && candleTwoDoji.isDoji
                                && Math.max(params.candleTwo_Close, params.candleTwo_Open) < Math.min(params.candleThree_Close, params.candleThree_Open)
                                && Math.max(params.candleTwo_Close, params.candleTwo_Open) < Math.min(params.candleOne_Close, params.candleOne_Open)
                                && candleOneDoji.isDoji;

    var isBearishContinuation = candleThreeDoji.isDoji
                                && candleTwoDoji.isDoji
                                && Math.min(params.candleTwo_Close, params.candleTwo_Open) > Math.max(params.candleThree_Close, params.candleThree_Open)
                                && Math.min(params.candleTwo_Close, params.candleTwo_Open) > Math.max(params.candleOne_Close, params.candleOne_Open)
                                && candleOneDoji.isDoji;
    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLUNIQUE3RIVER = function () {
    var params = CDLGETPARAMS(this.priceData);
    var isBullishContinuation = false, isBearishContinuation = false;

        var candleTwoUpperShadow = Math.abs(params.candleTwo_Open - params.candleTwo_High);
        var candleTwoBody = Math.abs(params.candleTwo_Open - params.candleTwo_Close);
        var candleTwoLowerShadow = Math.abs(params.candleTwo_Low - params.candleTwo_Close);
        var candleThreeBody = Math.abs(params.candleThree_Close - params.candleThree_Open);

        var isBullishContinuation = params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close))//The 1st candle has a long and bearish body
                                    && params.isCandleTwo_Bearish && params.candleTwo_Close > params.candleThree_Close && params.candleTwo_Open < params.candleThree_Open && params.candleTwo_Low < params.candleThree_Low //The 2nd candle is a hammer, and its body is inside the 1st bar's body;
                                    && params.isCandleOne_Bullish && params.candleOne_Close < params.candleTwo_Close; //tThe 3rd candle is small and bullish, its Close price is lower than 2nd bar's.

        //It's a bullish candlestick
        var isBearishContinuation = false;
    
    return {
        isBull: isBullishContinuation,
        isBear: isBearishContinuation
    };
}

CDL.prototype.CDLUPSIDEGAP2CROWS = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) //by a long white candlestick
                                && params.isCandleTwo_Bearish //small black candle with a body
                                && (params.candleTwo_Close > params.candleThree_Close)//  gapping above the prior candle's body.
                                && params.isCandleOne_Bearish && (params.candleOne_Close < params.candleTwo_Close && params.candleOne_Open > params.candleTwo_Open) //opening higher than the Day 2 open, but closing below the Day 2 close
                                && (params.candleOne_Close > params.candleThree_Close);// and above the Day 1 close

    //It's a bullish candlestick
    var isBearishContinuation = false;

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLXSIDEGAP3METHODS = function () {
    var params = CDLGETPARAMS(this.priceData);

    var isBullishContinuation = params.isCandleThree_Bullish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) //Long white
                                && params.isCandleTwo_Bullish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close)) //Long white
                                && (params.candleTwo_Open > params.candleThree_Close) //gaps above 1st day
                                && params.isCandleOne_Bearish && (params.candleOne_Open > params.candleTwo_Open) && (params.candleOne_Open < params.candleTwo_Close) //The third day opens lower, into the body of the top white (or green) candle 
                                && (params.candleOne_Close < params.candleThree_Close) && (params.candleOne_Close > params.candleThree_Open);//and closes into the body of the first white (or green) candle.

    var isBearishContinuation = params.isCandleThree_Bearish && (this.indicators.isLongCandle(params.candleThree_Open, params.candleThree_High, params.candleThree_Low, params.candleThree_Close)) //Long red
                                && params.isCandleTwo_Bearish && (this.indicators.isLongCandle(params.candleTwo_Open, params.candleTwo_High, params.candleTwo_Low, params.candleTwo_Close))  //Long red
                                && (params.candleTwo_Open < params.candleThree_Close) //gaps below 1st day
                                && params.isCandleOne_Bullish && (params.candleOne_Open < params.candleTwo_Open) && (params.candleOne_Open > params.candleTwo_Close)
                                && (params.candleOne_Close > params.candleThree_Close) && (params.candleOne_Close < params.candleThree_Open);


    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.CDLHIGHWAVE = function () {
    var params = CDLGETPARAMS(this.priceData);

    var bodySize = Math.abs(params.candleOne_Close - params.candleOne_Open);
    var candleSize = Math.abs(params.candleOne_High - params.candleOne_Low);
    var upperShadow = Math.abs(params.candleOne_High - Math.max(params.candleOne_Open, params.candleOne_Close));
    var lowerShadow = Math.abs(Math.min(params.candleOne_Open, params.candleOne_Close) - params.candleOne_Low);

    var isBearishContinuation = params.isCandleOne_Bearish && (bodySize > (Math.max(upperShadow, lowerShadow) * 0.05))
                                && ((bodySize < (lowerShadow / 3)) && (bodySize < (upperShadow / 3)));//�High Wave� is a candlestick with a small body and long shadows.

    var isBullishContinuation = params.isCandleOne_Bullish && (bodySize > (Math.max(upperShadow, lowerShadow) * 0.05))
                                && ((bodySize < (lowerShadow / 3)) && (bodySize < (upperShadow / 3)));//�High Wave� is a candlestick with a small body and long shadows.

    return {
        isBear: isBearishContinuation,
        isBull: isBullishContinuation
    };
}

CDL.prototype.calculateIndicatorValue = function(cdlPatternCode) {
    var ret;
    var time = this.priceData[this.priceData.length - 1].time;
    switch (cdlPatternCode.toUpperCase()) {
        case 'CDL2CROWS':
            var cdlObject = this.CDL2CROWS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TC', 'Two crows');
            break;
        case 'CDLDOJI':
            var candleOne_Index = this.priceData.length - 1;
            var candleOne_Open = this.priceData[candleOne_Index].open,
                candleOne_High = this.priceData[candleOne_Index].high,
                candleOne_Low = this.priceData[candleOne_Index].low,
                candleOne_Close = this.priceData[candleOne_Index].close;
            var cdlObject = this.CDLDOJI(candleOne_Open, candleOne_High, candleOne_Low, candleOne_Close);
            ret = CDLADDFLAGINFO(cdlObject, time, 'D', 'Doji');
            break;
        case 'CDL3BLACKCROWS':
            var cdlObject = this.CDL3BLACKCROWS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TBC', 'Three Black crows');
            break;
        case 'CDL3INSIDE':
            var cdlObject = this.CDL3INSIDE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TIUD', 'Three Inside Up/Down');
            break;
        case 'CDL3LINESTRIKE':
            var cdlObject = this.CDL3LINESTRIKE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TLS', 'Three-Line Strike');
            break;
        case 'CDL3OUTSIDE':
            var cdlObject = this.CDL3OUTSIDE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TOUD', 'Three Outside Up/Down');
            break;
        case 'CDL3STARSSOUTH':
            var cdlObject = this.CDL3STARSSOUTH();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TSS', 'Three Stars In The South');
            break;
        case 'CDL3WHITESOLDIERS':
            var cdlObject = this.CDL3WHITESOLDIERS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TWS', 'Three Advancing White Soldiers');
            break;
        case 'CDLABANDONEDBABY':
            var cdlObject = this.CDLABANDONEDBABY();
            ret = CDLADDFLAGINFO(cdlObject, time, 'AB', 'Abandoned Baby');
            break;
        case 'CDLADVANCEBLOCK':
            var cdlObject = this.CDLADVANCEBLOCK();
            ret = CDLADDFLAGINFO(cdlObject, time, 'AB', 'Advance Block');
            break;
        case 'CDLBELTHOLD':
            var cdlObject = this.CDLBELTHOLD();
            ret = CDLADDFLAGINFO(cdlObject, time, 'BH', 'Belt-hold');
            break;
        case 'CDLBREAKAWAY':
            var cdlObject = this.CDLBREAKAWAY();
            ret = CDLADDFLAGINFO(cdlObject, time, 'BA', 'Breakaway');
            break;
        case 'CDLCLOSINGMARUBOZU':
            var cdlObject = this.CDLCLOSINGMARUBOZU();
            ret = CDLADDFLAGINFO(cdlObject, time, 'CM', 'Closing Marubozu');
            break;
        case 'CDLCOUNTERATTACK':
            var cdlObject = this.CDLCOUNTERATTACK();
            ret = CDLADDFLAGINFO(cdlObject, time, 'CA', 'Counterattack');
            break;
        case 'CDLDARKCLOUDCOVER':
            var cdlObject = this.CDLDARKCLOUDCOVER();
            ret = CDLADDFLAGINFO(cdlObject, time, 'DCC', 'Dark Cloud Cover');
            break;
        case 'CDLDOJISTAR':
            var cdlObject = this.CDLDOJISTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'DS', 'Doji Star');
            break;
        case 'CDLDRAGONFLYDOJI':
            var cdlObject = this.CDLDRAGONFLYDOJI();
            ret = CDLADDFLAGINFO(cdlObject, time, 'DD', 'Dragonfly Doji');
            break;
        case 'CDLENGULFING':
            var cdlObject = this.CDLENGULFING();
            ret = CDLADDFLAGINFO(cdlObject, time, 'EP', 'Engulfing Pattern');
            break;
        case 'CDLEVENINGDOJISTAR':
            var cdlObject = this.CDLEVENINGDOJISTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'EDS', 'Evening Doji Star');
            break;
        case 'CDLEVENINGSTAR':
            var cdlObject = this.CDLEVENINGSTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'ES', 'Evening Star');
            break;
        case 'CDLGAPSIDESIDEWHITE':
            var cdlObject = this.CDLGAPSIDESIDEWHITE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'SSWL', 'Up/Down-Gap Side-By-Side White Lines');
            break;
        case 'CDLGRAVESTONEDOJI':
            var cdlObject = this.CDLGRAVESTONEDOJI();
            ret = CDLADDFLAGINFO(cdlObject, time, 'GSD', 'Gravestone Doji');
            break;
        case 'CDLHAMMER':
            var cdlObject = this.CDLHAMMER();
            ret = CDLADDFLAGINFO(cdlObject, time, 'H', 'Hammer');
            break;
        case 'CDLHANGINGMAN':
            var cdlObject = this.CDLHANGINGMAN();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HM', 'Hanging Man');
            break;
        case 'CDLHARAMI':
            var cdlObject = this.CDLHARAMI();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HP', 'Harami Pattern');
            break;
        case 'CDLHARAMICROSS':
            var cdlObject = this.CDLHARAMICROSS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HCP', 'Harami Cross Pattern');
            break;
        case 'CDLHOMINGPIGEON':
            var cdlObject = this.CDLHOMINGPIGEON();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HP', 'Homing Pigeon');
            break;
        case 'CDLHIKKAKE':
            var cdlObject = this.CDLHIKKAKE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HP', 'Hikkake Pattern');
            break;
        case 'CDLHIGHWAVE':
            var cdlObject = this.CDLHIGHWAVE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'HW', 'High Wave');
            break;
        case 'CDLIDENTICAL3CROWS':
            var cdlObject = this.CDLIDENTICAL3CROWS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'ITC', 'Identical Three Crows');
            break;
        case 'CDLINNECK':
            var cdlObject = this.CDLINNECK();
            ret = CDLADDFLAGINFO(cdlObject, time, 'IN', 'In-Neck');
            break;
        case 'CDLINVERTEDHAMMER':
            var cdlObject = this.CDLINVERTEDHAMMER();
            ret = CDLADDFLAGINFO(cdlObject, time, 'IH', 'Inverted Hammer');
            break;
        case 'CDLKICKING':
            var cdlObject = this.CDLKICKING();
            ret = CDLADDFLAGINFO(cdlObject, time, 'KC', 'Kicking');
            break;
        case 'CDLKICKINGBYLENGTH':
            var cdlObject = this.CDLKICKINGBYLENGTH();
            ret = CDLADDFLAGINFO(cdlObject, time, 'KCWLM', 'Kicking (longer marubozu)');
            break;
        case 'CDLLADDERBOTTOM':
            var cdlObject = this.CDLLADDERBOTTOM();
            ret = CDLADDFLAGINFO(cdlObject, time, 'LB', 'Ladder Bottom');
            break;
        case 'CDLLONGLEGGEDDOJI':
            var cdlObject = this.CDLLONGLEGGEDDOJI();
            ret = CDLADDFLAGINFO(cdlObject, time, 'LLD', 'Long Legged Doji');
            break;
        case 'CDLLONGLINE':
            var cdlObject = this.CDLLONGLINE();
            ret = CDLADDFLAGINFO(cdlObject, time, 'LLC', 'Long Line Candle');
            break;
        case 'CDLMARUBOZU':
            var candleOne_Index = this.priceData.length - 1;
            var candleOne_Open = this.priceData[candleOne_Index].open,
                candleOne_High = this.priceData[candleOne_Index].high,
                candleOne_Low = this.priceData[candleOne_Index].low,
                candleOne_Close = this.priceData[candleOne_Index].close;
            var cdlObject = this.CDLMARUBOZU(candleOne_Open, candleOne_High, candleOne_Low, candleOne_Close);
            ret = CDLADDFLAGINFO(cdlObject, time, 'MZ', 'Marubozu');
            break;
        case 'CDLMATCHINGLOW':
            var cdlObject = this.CDLMATCHINGLOW();
            ret = CDLADDFLAGINFO(cdlObject, time, 'ML', 'Matching Low');
            break;
        case 'CDLMATHOLD':
            var cdlObject = this.CDLMATHOLD();
            ret = CDLADDFLAGINFO(cdlObject, time, 'MH', 'Mat Hold');
            break;
        case 'CDLMORNINGDOJISTAR':
            var cdlObject = this.CDLMORNINGDOJISTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'MDS', 'Morning Doji Star');
            break;
        case 'CDLMORNINGSTAR':
            var cdlObject = this.CDLMORNINGSTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'MS', 'Morning Star');
            break;
        case 'CDLONNECK':
            var cdlObject = this.CDLONNECK();
            ret = CDLADDFLAGINFO(cdlObject, time, 'ON', 'On-Neck');
            break;
        case 'CDLPIERCING':
            var cdlObject = this.CDLPIERCING();
            ret = CDLADDFLAGINFO(cdlObject, time, 'PP', 'Piercing Pattern');
            break;
        case 'CDLRICKSHAWMAN':
            var cdlObject = this.CDLRICKSHAWMAN();
            ret = CDLADDFLAGINFO(cdlObject, time, 'RM', 'Rickshaw Man');
            break;
        case 'CDLRISEFALL3METHODS':
            var cdlObject = this.CDLRISEFALL3METHODS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'FTM', 'Falling Three Methods');
            break;
        case 'CDLSEPARATINGLINES':
            var cdlObject = this.CDLSEPARATINGLINES();
            ret = CDLADDFLAGINFO(cdlObject, time, 'SL', 'Separating Lines');
            break;
        case 'CDLSHOOTINGSTAR':
            var cdlObject = this.CDLSHOOTINGSTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'SS', 'Shooting Star');
            break;
        case 'CDLSPINNINGTOP':
            var cdlObject = this.CDLSPINNINGTOP();
            ret = CDLADDFLAGINFO(cdlObject, time, 'ST', 'Spinning Top');
            break;
        case 'CDLSTALLEDPATTERN':
            var cdlObject = this.CDLSTALLEDPATTERN();
            ret = CDLADDFLAGINFO(cdlObject, time, 'SP', 'Stalled Pattern');
            break;
        case 'CDLSTICKSANDWICH':
            var cdlObject = this.CDLSTICKSANDWICH();
            ret = CDLADDFLAGINFO(cdlObject, time, 'SS', 'Stick Sandwich');
            break;
        case 'CDLTAKURI':
            var cdlObject = this.CDLTAKURI();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TK', 'Takuri');
            break;
        case 'CDLTASUKIGAP':
            var cdlObject = this.CDLTASUKIGAP();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TG', 'Tasuki Gap');
            break;
        case 'CDLTHRUSTING':
            var cdlObject = this.CDLTHRUSTING();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TP', 'Thrusting Pattern');
            break;
        case 'CDLTRISTAR':
            var cdlObject = this.CDLTRISTAR();
            ret = CDLADDFLAGINFO(cdlObject, time, 'TSP', 'Tristar Pattern');
            break;
        case 'CDLUNIQUE3RIVER':
            var cdlObject = this.CDLUNIQUE3RIVER();
            ret = CDLADDFLAGINFO(cdlObject, time, 'U3R', 'Unique 3 River');
            break;
        case 'CDLUPSIDEGAP2CROWS':
            var cdlObject = this.CDLUPSIDEGAP2CROWS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'UGTC', 'Upside Gap Two Crows');
            break;
        case 'CDLXSIDEGAP3METHODS':
            var cdlObject = this.CDLXSIDEGAP3METHODS();
            ret = CDLADDFLAGINFO(cdlObject, time, 'GTM', 'Upside/Downside Gap Three Methods');
            break;
    }
    return ret;
};

CDLADDFLAGINFO = function (cdlObject, time, shortDisplayName, longDisplayName) {
    var ret;
    if (cdlObject.isBull) {
        ret = {
            x: time,
            title: '<span style="color : blue">' + shortDisplayName + '</span>',
            text: longDisplayName + ' : Bull'
        };
    }
    else if (cdlObject.isBear) {
        ret = {
            x: time,
            title: '<span style="color : red">' + shortDisplayName + '</span>',
            text: longDisplayName + ' : Bear'
        };
    }
    return ret;
};

CDLGETPARAMS = function (priceData) {
    var candleOne_Index = priceData.length - 1;
    var candleTwo_Index = candleOne_Index - 1;
    var candleThree_Index = candleOne_Index - 2;
    var candleFour_Index = candleOne_Index - 3;
    var candleFive_Index = candleOne_Index - 4;

    var candleParams = {
        candleOne_Open: priceData[candleOne_Index].open,
        candleOne_Close: priceData[candleOne_Index].close,
        candleOne_High: priceData[candleOne_Index].high,
        candleOne_Low: priceData[candleOne_Index].low,
        candleTwo_Open: priceData[candleTwo_Index].open,
        candleTwo_Close: priceData[candleTwo_Index].close,
        candleTwo_High: priceData[candleTwo_Index].high,
        candleTwo_Low: priceData[candleTwo_Index].low,
        candleThree_Open: priceData[candleThree_Index].open,
        candleThree_Close: priceData[candleThree_Index].close,
        candleThree_High: priceData[candleThree_Index].high,
        candleThree_Low: priceData[candleThree_Index].low,
        isCandleOne_Bullish: priceData[candleOne_Index].close > priceData[candleOne_Index].open,
        isCandleOne_Bearish: priceData[candleOne_Index].close < priceData[candleOne_Index].open,
        isCandleTwo_Bullish: priceData[candleTwo_Index].close > priceData[candleTwo_Index].open,
        isCandleTwo_Bearish: priceData[candleTwo_Index].close < priceData[candleTwo_Index].open,
        isCandleThree_Bullish: priceData[candleThree_Index].close > priceData[candleThree_Index].open,
        isCandleThree_Bearish: priceData[candleThree_Index].close < priceData[candleThree_Index].open
    };

    candleParams.candleFour_Index = candleFour_Index;
    if (candleFour_Index >= 0) {
        candleParams.candleFour_Open = priceData[candleFour_Index].open;
        candleParams.candleFour_Close = priceData[candleFour_Index].close;
        candleParams.candleFour_High = priceData[candleFour_Index].high;
        candleParams.candleFour_Low = priceData[candleFour_Index].low;
        candleParams.isCandleFour_Bullish = priceData[candleFour_Index].close > priceData[candleFour_Index].open;
        candleParams.isCandleFour_Bearish = priceData[candleFour_Index].close < priceData[candleFour_Index].open;
    };

    candleParams.candleFive_Index = candleFive_Index;
    if (candleFive_Index >= 0) {
        candleParams.candleFive_Open = priceData[candleFive_Index].open;
        candleParams.candleFive_Close = priceData[candleFive_Index].close;
        candleParams.candleFive_High = priceData[candleFive_Index].high;
        candleParams.candleFive_Low = priceData[candleFive_Index].low;
        candleParams.isCandleFive_Bullish = priceData[candleFive_Index].close > priceData[candleFive_Index].open;
        candleParams.isCandleFive_Bearish = priceData[candleFive_Index].close < priceData[candleFive_Index].open;
    };

    return candleParams;
}
/**
 * Created by Mahboob.M on 2/6/16.
 */

CHOP = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
   
    this.calculateCHOPValue = function (data, index) {
        /*Chop= 100 * LOG10( SUM(ATR(1), n) / ( MaxHi(n) - MinLo(n) ) ) / LOG10(n)
        n = User defined period length.
        LOG10(n) = base-10 LOG of n
        ATR(1) = Average True Range (Period of 1)
        SUM(ATR(1), n) = Sum of the Average True Range over past n bars 
        MaxHi(n) = The highest high over past n bars.*/
        var sumAtr = 0.0, highestHigh = data[index].high, lowestLow = data[index].low;
        for (var i = 0; i < this.options.period; i++) {
            sumAtr += this.atr.indicatorData[index - i].value;
            highestHigh = Math.max(data[index - i].high, highestHigh);
            lowestLow = Math.min(data[index - i].low, lowestLow);
        };
        var chop = 0;
        if ((highestHigh - lowestLow) !== 0) {
            chop = (100 * Math.log10(sumAtr / (highestHigh - lowestLow))) / Math.log10(this.options.period)
        };
        return toFixed(chop, 4);
    };

    this.atr = new ATR(data, { period: this.options.atrPeriod, appliedTo: this.options.appliedTo }, indicators);

    for (var index = 0; index < data.length; index++) {
        if (index >= options.period) {
            var chop = this.calculateCHOPValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: chop });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    };
};

CHOP.prototype = Object.create(IndicatorBase.prototype);
CHOP.prototype.constructor = CHOP;

CHOP.prototype.addPoint = function (data) {
    console.log('Adding CHOP data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    this.atr.addPoint(data)[0].value;
    var chop = this.calculateCHOPValue(this.priceData, index);
    this.indicatorData.push({ time: data.time, value: chop });
    return [{
        id: this.uniqueID,
        value: chop
    }];
};

CHOP.prototype.update = function (data) {
    console.log('Updating CHOP data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    this.atr.update(data)[0].value;
    var chop = this.calculateCHOPValue(this.priceData, index);
    this.indicatorData[index].value = chop;
    return [{
        id: this.uniqueID,
        value: chop
    }];
};

CHOP.prototype.toString = function () {
    return 'CHOP (' + this.options.period + ', ' + this.options.atrPeriod + ', '+ this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

CKS = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.highStops = [];
    this.lowStops = [];
    this.shortStops = [];

    //2 unique IDs for 2 series to be rendered
    //long stop line (blue) and and a short stop line (red)
    this.uniqueID = [uuid(), uuid()];

    /*Calculate CKS
    first high stop = HIGHEST[p](high) - x * Average True Range[p]
    first low stop = LOWEST[p](high) + x * Average True Range[p]
    long stop= HIGHEST[q](first high stop)
    short stop= LOWEST[q](first low stop) 
    */
    this.atr = new ATR(data, options, indicators);

    this.calculateStopValue = function (data,index) {
        var higestHigh = data[index].high;
        var lowestLow = data[index].low;
        for (var i = 0; i < this.options.period; i++) {
            if (index - i > 0) {
                higestHigh = Math.max(data[index - i].high, higestHigh);
                lowestLow = Math.min(data[index - i].low, lowestLow);
            };
        }
        var highStopValue = higestHigh - (this.options.multiplier * this.atr.indicatorData[index].value);
        var lowStopValue = lowestLow + (this.options.multiplier * this.atr.indicatorData[index].value);
        return {
            highStop: highStopValue,
            lowStop: lowStopValue
        }
    };

    this.calculateCKSValue = function (index) {
        var longStop = this.highStops[index].value;
        var shortStop = this.lowStops[index].value;
        for (var i = 0; i < this.options.maxMinPeriod; i++) {
            if (index - i > 0) {
                longStop = Math.max(this.highStops[index - i].value, longStop);
                shortStop = Math.min(this.lowStops[index - i].value, shortStop);
            };
        }
        return {
            longStop: toFixed(longStop,4),
            shortStop: toFixed(shortStop,4)
        }
    };

    for (var index = 0; index < data.length; index++) {
        var stop = this.calculateStopValue(data, index);
        this.highStops.push({ time: data[index].time, value: stop.highStop });
        this.lowStops.push({ time: data[index].time, value: stop.lowStop });
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var cks = this.calculateCKSValue(index);
            this.indicatorData.push({ time: data[index].time, value: cks.longStop });
            this.shortStops.push({ time: data[index].time, value: cks.shortStop });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
            this.shortStops.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

CKS.prototype = Object.create(IndicatorBase.prototype);
CKS.prototype.constructor = CKS;

CKS.prototype.addPoint = function (data) {
    console.log('Adding CKS data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var atr = this.atr.addPoint(data)[0].value;
    var stop = this.calculateStopValue(this.priceData, index);
    this.highStops.push({ time: data.time, value: stop.highStop });
    this.lowStops.push({ time: data.time, value: stop.lowStop });
    var cks = this.calculateCKSValue(index);
    this.indicatorData.push({ time: data.time, value: cks.longStop });
    this.shortStops.push({ time: data.time, value: cks.shortStop });
     return [{
        id: this.uniqueID[1],
        value: cks.longStop
        }, {
        id: this.uniqueID[0],
        value: cks.shortStop
    }];
};

CKS.prototype.update = function (data) {
    console.log('Updating CKS data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var atr = this.atr.update(data)[0].value;;
    var stop = this.calculateStopValue(this.priceData, index);
    this.highStops[index].value = stop.highStop;
    this.lowStops[index].value = stop.lowStop;
    var cks = this.calculateCKSValue(index);
    this.indicatorData[index].value = cks.longStop;
    this.shortStops[index].value = cks.shortStop;
    return [{
        id: this.uniqueID[1],
        value: cks.longStop
        }, {
        id: this.uniqueID[0],
        value: cks.shortStop
    }];
};

CKS.prototype.toString = function () {
    return 'CKS (' + this.options.period + ', ' + this.options.maxMinPeriod + ', ' + this.options.multiplier + ')';
};


/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
CKS.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {

    //Prepare the data before sending a configuration
    var longStopData = [];
    this.indicatorData.forEach(function (e) {
        longStopData.push([e.time, e.value]);
    });
    var  shortStopData = [];
    this.shortStops.forEach(function (e) {
        shortStopData.push([e.time, e.value]);
    });

    return [
        {
            seriesConf: {
                id: this.uniqueID[0],
                name: 'Short Stop - ' + this.toString(),
                data: shortStopData,
                type: 'line',
                color: this.options.shortStopStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf: {
                id: this.uniqueID[1],
                name: 'Long Stop - ' + this.toString(),
                data: longStopData,
                type: 'line',
                color: this.options.longStopStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
CKS.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
CKS.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Mahboob.M on 2/9/16.
 */

CMO = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /* CMO :
    diff = Pi - Pi-1,
    where Pi -the price (usually closing price) of the current period;
    Pi-1 -the price (usually closing price) of the previous period;
    If diff > 0, then cmo1i = diff, cmo2i = 0.
    If diff < 0, then cmo2i = -diff, cmo1i = 0.
    sum1 = Sum(cmo1, n) - summary value of cmo1 within n periods.
    sum2 = Sum(cmo2, n) - summary value of cmo2 within n periods.
    CMO = ((sum1-sum2)/(sum1+sum2))* 100
    */
    this.CalculateCMOValue = function (index) {
        var sumPos = 0, sumNeg = 0;
        for (var i = 0; i < this.options.period; i++) {
            sumPos += this.posData[index - i].value;
            sumNeg += this.negData[index - i].value;
        }
        return {
            sumPos: sumPos,
            sumNeg: sumNeg
        };
    };

    this.CalculatePosNegValue = function (data, index) {
        var diff = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo) - this.indicators.getIndicatorOrPriceValue(data[index - 1], this.options.appliedTo);
        var pos = 0, neg = 0;
        if (diff > 0) { pos = diff };
        if (diff < 0) { neg = Math.abs(diff) };
        return {
            pos: pos,
            neg: neg
        };
    };

    this.posData = [{ time: data[0].time, close: 0 }], this.negData = [{ time: data[0].time, close: 0 }];
    for (var index = 1; index < data.length; index++) {
        var result = this.CalculatePosNegValue(data, index);
        this.posData.push({ time: data[index].time, value: result.pos });
        this.negData.push({ time: data[index].time, value: result.neg });
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var sum = this.CalculateCMOValue(index);
            var cmo = 0;
            if (sum.sumPos + sum.sumNeg !== 0)
                cmo = toFixed(((sum.sumPos - sum.sumNeg) / (sum.sumPos + sum.sumNeg) * 100), 4);
            this.indicatorData.push({ time: data[index].time, value: cmo });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        };
        this.priceData.push(data[index]);
    };
};

CMO.prototype = Object.create(IndicatorBase.prototype);
CMO.prototype.constructor = CMO;

CMO.prototype.addPoint = function (data) {
    console.log('Adding CMO data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var result = this.CalculatePosNegValue(this.priceData, index);
    this.posData.push({ time: data.time, value: result.pos });
    this.negData.push({ time: data.time, value: result.neg });
    var sum = this.CalculateCMOValue(index);
    var cmo = (sum.sumPos + sum.sumNeg !== 0) ? toFixed(((sum.sumPos - sum.sumNeg) / (sum.sumPos + sum.sumNeg) * 100), 4) : 0;
    this.indicatorData.push({ time: data.time, value: cmo });
    return [{
        id: this.uniqueID,
        value: cmo
    }];
};

CMO.prototype.update = function (data) {
    console.log('Updating CMO data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var result = this.CalculatePosNegValue(this.priceData, index);
    this.posData[index].value = result.pos;
    this.negData[index].value = result.neg;
    var sum = this.CalculateCMOValue(index);
    var cmo = (sum.sumPos + sum.sumNeg !== 0) ? toFixed(((sum.sumPos - sum.sumNeg) / (sum.sumPos + sum.sumNeg) * 100), 4) : 0;
    this.indicatorData[index].value = cmo;
    return [{
        id: this.uniqueID,
        value: cmo
    }];
};

CMO.prototype.toString = function () {
    return 'CMO (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/8/16.
 */
DC = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.lowData = [];
    this.areaRangeData = [];
    this.priceData = [];
    //3 unique IDs for 4 series to be rendered
    this.uniqueID = [uuid(), uuid(), uuid()];
    this.calculateDCValue = function (data, index) {
        /* It is formed by taking the highest high and the lowest low of the last n periods. The area between the high and the low is the channel for the period chosen.*/
        var highestHigh = data[index].high, lowestLow = data[index].low;
        for (var i = 0; i < this.options.period; i++) {
            if (index - i >= 0) {
                highestHigh = Math.max(data[index - i].high, highestHigh);
                lowestLow = Math.min(data[index - i].low,lowestLow);
            }
        };
        return {
            highestHigh: highestHigh,
            lowestLow: lowestLow
        };
    };
    for (var index = 0; index < data.length; index++) {
        var value = this.calculateDCValue(data, index);
        this.indicatorData.push({ time: data[index].time, value: value.highestHigh });
        this.lowData.push({ time: data[index].time, value: value.lowestLow });
        this.areaRangeData.push({ time: data[index].time, value: [value.highestHigh, value.lowestLow] });
        this.priceData.push(data[index]);
    };
};

DC.prototype = Object.create(IndicatorBase.prototype);
DC.prototype.constructor = DC;

DC.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var value = this.calculateDCValue(this.priceData, index);
    this.indicatorData.push({ time: data.time, value: value.highestHigh });
    this.lowData.push({ time: data.time, value: value.lowestLow });
    this.areaRangeData.push({ time: data.time, value: [value.highestHigh, value.lowestLow] });
    return [{
        id: this.uniqueID[0],
        value: value.highestHigh
    }, {
        id: this.uniqueID[1],
        value: value.lowestLow
    }, {
        id: this.uniqueID[2],
        value: [value.highestHigh, value.lowestLow]
    }];
};

DC.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var value = this.calculateDCValue(this.priceData, index);
    this.indicatorData[index].value = value.highestHigh;
    this.lowData[index].value = value.lowestLow;
    this.areaRangeData[index].value = value.lowestLow;
    return [{
        id: this.uniqueID[0],
        value: value.highestHigh
    }, {
        id: this.uniqueID[1],
        value: value.lowestLow
    }, {
        id: this.uniqueID[2],
        value: [value.highestHigh, value.lowestLow]
    }];
};

DC.prototype.toString = function() {
    return 'DC (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
DC.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    //Prepare the data before sending a configuration
    var highData = [];
    this.indicatorData.forEach(function(e) {
        highData.push([e.time, e.value]);
    });
    var lowData = [];
    this.lowData.forEach(function(e) {
        lowData.push([e.time, e.value]);
    });
    var rangeData = [];
    this.areaRangeData.forEach(function(e) {
        rangeData.push(_.flattenDeep([e.time, e.value]));
    });
    return [
        {
            seriesConf : {
                id: this.uniqueID[0],
                name: 'High - ' + this.toString(),
                data: highData,
                type: 'line',
                color: this.options.highStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf : {
                id: this.uniqueID[1],
                name: 'Low - ' + this.toString(),
                data: lowData,
                type: 'line',
                color: this.options.lowStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: true
            }
        },
        {
            seriesConf: {
                id: this.uniqueID[2],
                data: rangeData,
                name: "DC Range",
                type: 'arearange',
                color: 'white',
                fillColor: 'rgba(28,28,28,0.2)',
                connectNulls: true,
                //Following properties, states, events, dataLabels, point are needed. Otherwise higcharts-more throws error
                states: {
                    hover: {
                        enabled: false
                    }
                },
                events: {},
                dataLabels: {
                    enabled: false
                },
                point: {
                    events: {}
                },
                enableMouseTracking: false,
                onChartIndicator: true
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
DC.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
DC.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
DEMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.ema1 = null, this.ema2 = null;

    /*
     The Double Exponential Moving Average (DEMA) of time series 't' is:
     *      EMA1 = EMA(t,period)
     *      EMA2 = EMA(EMA1,period)
     *      DEMA = 2 * EMA1 - EMA2
     * Do not fill any value in DemaData from 0 index to options.period-1 index
     */
    this.ema1 = new EMA(data, {
        period : options.period,
        appliedTo : options.appliedTo
    }, indicators);
    var ema1Data = [];
    this.ema1.indicatorData.forEach(function(e) {
        ema1Data.push({time : e.time, close : e.value});
    });
    this.ema2 = new EMA(ema1Data, {
        period : options.period,
        appliedTo : indicators.CLOSE
    }, indicators);

    for (var index = 0; index < data.length; index++) {
        var dema1Value = this.ema1.indicatorData[index].value;
        var dema2Value = this.ema2.indicatorData[index].value;
        var dema = toFixed(2 * dema1Value - dema2Value, 4);
        this.indicatorData.push({ time : data[index].time, value : dema });
    }

};

DEMA.prototype = Object.create(IndicatorBase.prototype);
DEMA.prototype.constructor = DEMA;

DEMA.prototype.addPoint = function(data) {
    var dema1Value = this.ema1.addPoint(data)[0].value;
    var dema2Value = this.ema2.addPoint({ time : data.time, close : dema1Value})[0].value;
    var dema = toFixed(2 * dema1Value - dema2Value, 4);
    this.indicatorData.push({ time : data.time, value : dema });
    return [{
        id : this.uniqueID,
        value : dema
    }];
};

DEMA.prototype.update = function(data) {
    var index = this.indicatorData.length - 1;
    var dema1Value = this.ema1.update(data)[0].value;
    var dema2Value = this.ema2.update({ time : data.time, close : dema1Value})[0].value;
    var dema = toFixed(2 * dema1Value - dema2Value, 4);
    console.log('DEMA value : ', dema1Value, dema2Value, dema);
    this.indicatorData[index].value = dema;
    return [{
        id : this.uniqueID,
        value : dema
    }];
};

DEMA.prototype.toString = function() {
    return 'DEMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/6/16.
 */

DX = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    /*Current High - Previous High = UpMove
    Current Low - Previous Low = DownMove
    If UpMove > DownMove and UpMove > 0, then +DM = UpMove, else +DM = 0
    If DownMove > Upmove and Downmove > 0, then -DM = DownMove, else -DM = 0
    +DI = 100 times Exponential Moving Average of (+DM / Average True Range)
    -DI = 100 times Exponential Moving Average of (-DM / Average True Range)
    DX = 100 times the Exponential Moving Average of the Absolute Value of (+DI- -DI) / (+DI + -DI).*/
    this.uniqueID = [uuid(), uuid(), uuid()];
    this.adx = new ADX(data, options, indicators);
    this.plusDIData = this.adx.PlusDI.indicatorData;
    this.minusData = this.adx.MinusDI.indicatorData;
    this.indicatorData = this.adx.indicatorData;
};

DX.prototype = Object.create(IndicatorBase.prototype);
DX.prototype.constructor = DX;

DX.prototype.addPoint = function (data) {
    console.log('Adding DX data point : ', data);
    var adx = this.adx.addPoint(data)[0].value;
    this.plusDIData = this.adx.PlusDI.indicatorData;
    this.minusData = this.adx.MinusDI.indicatorData;
    this.indicatorData = this.adx.indicatorData;
    return [{
        id: this.uniqueID[0],
        value: adx
    }, {
        id: this.uniqueID[1],
        value: this.plusDIData[this.plusDIData.length - 1].value
    }, {
        id: this.uniqueID[2],
        value: this.minusData[this.minusData.length - 1].value
    }];
};

DX.prototype.update = function (data) {
    console.log('Updating DX data point : ', data);
    var adx = this.adx.update(data)[0].value;
    this.plusDIData = this.adx.PlusDI.indicatorData;
    this.minusData = this.adx.MinusDI.indicatorData;
    this.indicatorData = this.adx.indicatorData;
    return [{
        id: this.uniqueID[0],
        value: adx
    }, {
        id: this.uniqueID[1],
        value: this.plusDIData[this.plusDIData.length - 1].value
    }, {
        id: this.uniqueID[2],
        value: this.minusData[this.minusData.length - 1].value
    }];
};

DX.prototype.toString = function () {
    return 'DX (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};


/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
DX.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    //Prepare the data before sending a configuration
    var adxData = [];
    this.indicatorData.forEach(function (e) {
        adxData.push([e.time, e.value]);
    });

    var plusDIData = [];
    this.plusDIData.forEach(function (e) {
        plusDIData.push([e.time, e.value]);
    });

    var minusData = [];
    this.minusData.forEach(function (e) {
        minusData.push([e.time, e.value]);
    });

    return [{
            axisConf: { // Secondary yAxis
                id: indicatorMetadata.id + '-' + this.uniqueID[0],
                title: {
                    text: this.toString(),
                    align: 'high',
                    offset: 0,
                    rotation: 0,
                    y: 10, //Trying to show title inside the indicator chart
                    x: 30+ this.toString().length * 7.5
                },
                lineWidth: 2,
                plotLines: this.options.levels
             }
         },
         {
            seriesConf: {
                 id: this.uniqueID[0],
                 name: 'ADX ' + this.toString(),
                 data: adxData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.dxStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[1],
                 name: '+DI ' + this.toString(),
                 data: plusDIData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.plusDIStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[2],
                 name: '-DI ' + this.toString(),
                 data: minusData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.minusDIStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         }];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
DX.prototype.getIDs = function () {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
DX.prototype.isSameInstance = function (uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
EMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);

    /*  ema(t) = p(t) * 2/(T+1) + ema(t-1) * (1 - 2 / (T+1))
     *  Do not fill any value in emaData from 0 index to options.period-1 index
     */
    for (var index = 0; index < data.length; index++) {
        if (index === (this.options.period - 1)) {
            var sum = 0.0;
            for (var i = this.options.period - 1; i >= 0; i--) {
                sum += indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            }
            var sma = toFixed(sum / this.options.period, 4);
            this.indicatorData.push({ time : data[index].time, value : sma });
        } else if(index > (this.options.period - 1)) {
            var preEma = this.indicatorData[index - 1].value;
            var price = indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var ema = (price * 2 / (this.options.period + 1)) + (preEma * (1 - 2 / (this.options.period + 1)));
            ema = toFixed(ema, 4);
            this.indicatorData.push({ time : data[index].time, value : ema });
        } else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
    }

};

EMA.prototype = Object.create(IndicatorBase.prototype);
EMA.prototype.constructor = EMA;

EMA.prototype.addPoint = function(data) {
    var index = this.indicatorData.length - 1;
    var preEma = this.indicatorData[index].value;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var ema = (price * 2 / (this.options.period + 1)) + (preEma * (1 - 2 / (this.options.period + 1)));
    ema = toFixed(ema, 4);
    this.indicatorData.push({ time : data.time, value : ema });
    return [{
        id : this.uniqueID,
        value : ema
    }];
};

EMA.prototype.update = function(data) {
    var index = this.indicatorData.length - 1;
    var preEma = this.indicatorData[index - 1].value;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var ema = (price * 2 / (this.options.period + 1)) + (preEma * (1 - 2 / (this.options.period + 1)));
    ema = toFixed(ema, 4);
    this.indicatorData[index].value = ema;
    return [{
        id : this.uniqueID,
        value : ema
    }];
};

EMA.prototype.toString = function() {
    return 'EMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/18/16.
 */

FRACTAL = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.BULL = 1, this.BEAR = 2;
    this.middleBar_shift = Math.floor(this.options.numberOfBars / 2) | 0;
    
    this.BULL_IMAGE_URL = 'url(images/indicators/down_fractal.svg)';
    this.BEAR_IMAGE_URL = 'url(images/indicators/up_fractal.svg)';

    /**
     * @param data
     * @param middleBarIndex
     * @param checkFor - Whether to the calculation for bull or bear
     * @returns {*}
     * @constructor
     */
    this.CalculateFRACTALValue = function (data, middleBarIndex, checkFor) {

        /* FRACTAL :
         Two candles marking lower highs / higher lows to the left
         The fractal over the higher high / under the lower low
         Two candles marking lower highs / higher lows to the right*/
        if ((middleBarIndex - this.middleBar_shift) < 0 || (middleBarIndex + this.middleBar_shift) > data.length - 1) return null;

        var candleMiddle_High = data[middleBarIndex].high, candleMiddle_Low = data[middleBarIndex].low;

        var prices = _.range(middleBarIndex - this.middleBar_shift, middleBarIndex + this.middleBar_shift + 1)
                        .map(function(index) {
                            return data[index];
                        });
        var lowPrices = prices.map(function(val) { return val.low; });
        var highPrices = prices.map(function(val) { return val.high; });
        var lowestPrice = _.min(lowPrices);
        var highestPrice = _.max(highPrices);
        var isBull = (lowestPrice === candleMiddle_Low);
        var isBear = (highestPrice === candleMiddle_High);
        var pos = candleMiddle_Low;
        if (checkFor === this.BEAR) pos = candleMiddle_High;

        /*require(['moment'], function( moment ) {
            console.log(moment(data[data.length - 1].time).format('YYYY-MM-DD HH:mm'),
                            moment(data[data.length - 2].time).format('YYYY-MM-DD HH:mm'),
                                moment(data[middleBarIndex].time).format('YYYY-MM-DD HH:mm'), middleBarIndex, data.length);
        });*/

        return new FractalUpdateObject(data[middleBarIndex].time || data[middleBarIndex].x, pos,
                        (isBull && checkFor === this.BULL) || (isBear && checkFor === this.BEAR) ? ' ' : '',
                        'Fractal: ' + pos,
                        {
                            symbol: checkFor === this.BULL? this.BULL_IMAGE_URL : (checkFor === this.BEAR? this.BEAR_IMAGE_URL : null)
                        },
                        (isBull && checkFor === this.BULL),
                        (isBear && checkFor === this.BEAR)
                    );

    };

    for (var index = 0; index < data.length; index++) {
        this.priceData.push(data[index]);
        var parent = this;
        [this.BULL, this.BEAR].forEach(function(checkFor) {
            var ret = parent.CalculateFRACTALValue(data, index, checkFor);
            if (ret && !_.isEmpty(ret.text) && !_.isEmpty(ret.title) && ret.marker && ret.marker.symbol) {
                parent.indicatorData.push(ret);
            }
        });
    };

    console.log('Fractal, Init last data point', new Date(data[data.length - 1].time));

    this.addOrUpdateFractalData = function(mode) {
        //The fractal needs two next data for each point to find the pattern,so when a new data is added, we should check if the second previous
        // data is going to be fractal or not based on new data.
        var index = this.priceData.length - 1 - this.middleBar_shift;
        var parent = this;
        var returnObject = [];
        [this.BULL, this.BEAR].forEach(function(checkFor) {
            var ret = parent.CalculateFRACTALValue(parent.priceData, index, checkFor);
            if (ret && ret.marker && ret.marker.symbol) {
                //console.log( mode === 'add' ? 'Adding' : 'Updating', 'FRACTAL data point : ', ret, data, checkFor);
                if ( mode === 'add' ) {
                    parent.indicatorData.push(ret);
                    returnObject.push({
                        id: parent.uniqueID,
                        value: ret
                    });
                }
            }

            //We have to add ret with any value in update mode so that invalid fractal points are removed
            if (mode === 'update') {
                returnObject.push({
                    id: parent.uniqueID,
                    value: ret
                });
            }
        });

        console.log(mode, returnObject);
        return returnObject;
    };

};

FractalUpdateObject = function(x, y, title, text, marker, isBull, isBear) {
    this.y = y;
    this.x = x;
    this.title = title;
    this.text = text;
    this.marker = marker;
    this.isBull = isBull;
    this.isBear = isBear;
    this.toJSObject = function() {
        return {
            x : x,
            y : y,
            title : title,
            text : text,
            marker : marker
        };
    };
};

FRACTAL.prototype = Object.create(IndicatorBase.prototype);
FRACTAL.prototype.constructor = FRACTAL;

FRACTAL.prototype.addPoint = function (data) {
    //console.log('Adding FRACTAL data point :', data);
    //Don't process same time data points
    this.priceData.push(data);
    console.log('[Fractal], last data point', new Date(this.priceData[this.priceData.length - 1].time), ', second last data point', new Date(this.priceData[this.priceData.length - 2].time));
    return this.addOrUpdateFractalData( 'add' );
};

FRACTAL.prototype.update = function (data) {
    //console.log('Updating FRACTAL data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    return this.addOrUpdateFractalData( 'update' );
};

FRACTAL.prototype.toString = function () {
    return 'FRACTAL (' + this.options.numberOfBars + ')';
};

FRACTAL.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    console.log(indicatorMetadata, indicatorMetadata.onChartIndicator);
     return [
        {
            seriesConf: {
                id: this.uniqueID,
                name: this.toString(),
                data: this.indicatorData,
                type: 'scatter',
                turboThreshold: 0,
                onChartIndicator: indicatorMetadata.onChartIndicator,
                enableMouseTracking:false,
                onSeries: this.options.onSeriesID //Series ID on which this flags will be rendered
            }
        }
    ];
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
HMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.someTypeOfMa1 = null, this.someTypeOfMa2 = null, this.someTypeOfMa3 = null;

    // HMA(n) = WMA(2*WMA(n/2) – WMA(n)),sqrt(n))
    var maClassName = (options.maType || 'sma').toUpperCase();
    var n = Math.round(options.period / 2) | 0;
    this.someTypeOfMa1 = new window[maClassName](data, {
        period : n,
        appliedTo : options.appliedTo
    }, indicators);
    this.someTypeOfMa2 = new window[maClassName](data, {
        period : options.period,
        appliedTo : options.appliedTo
    }, indicators);

    var dataForHma = [];
    for (var index = 0; index < data.length; index++) {
        var ma1Value = this.someTypeOfMa1.indicatorData[index].value;
        var ma2Value = this.someTypeOfMa2.indicatorData[index].value;
        var ma3Value = 2 * ma1Value - ma2Value;
        dataForHma.push({ time : data[index].time, close : ma3Value });
    }
    var hmaPeriod = Math.round(Math.sqrt(options.period)) | 0;
    this.someTypeOfMa3 = new window[maClassName](dataForHma, {
        period : hmaPeriod,
        appliedTo : indicators.CLOSE
    }, indicators);
    this.indicatorData = this.someTypeOfMa3.indicatorData;

};

HMA.prototype = Object.create(IndicatorBase.prototype);
HMA.prototype.constructor = HMA;

HMA.prototype.addPoint = function(data) {
    var ma1Value = this.someTypeOfMa1.addPoint(data)[0].value;
    var ma2Value = this.someTypeOfMa2.addPoint(data)[0].value;
    var ma3Value = 2 * ma1Value - ma2Value;
    var hma = this.someTypeOfMa3.addPoint({time : data.time, close : ma3Value})[0].value;
    this.indicatorData = this.someTypeOfMa3.indicatorData;
    return [{
        id : this.uniqueID,
        value : hma
    }];
};

HMA.prototype.update = function(data) {
    var ma1Value = this.someTypeOfMa1.update(data)[0].value;
    var ma2Value = this.someTypeOfMa2.update(data)[0].value;
    var ma3Value = 2 * ma1Value - ma2Value;
    var hma = this.someTypeOfMa3.update({time : data.time, close : ma3Value})[0].value;
    this.indicatorData = this.someTypeOfMa3.indicatorData;
    return [{
        id : this.uniqueID,
        value : hma
    }];
};

HMA.prototype.toString = function() {
    return 'HMA (' + this.options.period  + ', '
        + this.indicators.appliedPriceString(this.options.appliedTo) + ', '
        + this.options.maType + ')';
};

/**
 * Created by arnab on 3/30/15.
 */
define(['jquery', 'lodash', 'common/util', 'highcharts-more'], function ($, _) {

    var indicatorsMetaData = [];
    require(['text!charts/indicators/indicators.json'], function (indicatorsJSON) {
        indicatorsMetaData = _.cloneDeep(JSON.parse(indicatorsJSON));
    });

    function updateOrAddScatterOrFlagSeriesData(iu, indicatorSeries) {
        var seriesData = indicatorSeries.data;
        if (iu.value && _.isFunction(iu.value.toJSObject)) {
            var x = iu.value.x;
            var matchingSeriesData = _.find(seriesData, function (ee) {
                var isTrue = _.isNumber(x) && x > 0 && x === ee.x;
                if (isTrue && iu.value.marker) {
                    isTrue = iu.value.marker.symbol === ee.marker.symbol;
                }
                return isTrue;
            });
            if (matchingSeriesData) {
                console.log('[remove] series name', indicatorSeries.options.name, matchingSeriesData.x);
                matchingSeriesData.remove();
            }
            //console.log('renderingData', renderingData);
            if (_.isNumber(x) && x > 0 && !_.isEmpty(iu.value.text) && !_.isEmpty(iu.value.title)) {
                console.log('Adding, series length', indicatorSeries.data.length, iu.value.text, x);
                indicatorSeries.addPoint(iu.value);
            }
        }
    }

    var indicators = {

        OPEN: 0, HIGH: 1, LOW: 2, CLOSE: 3,

        initHighchartIndicators : function(barsTable) {
            Highcharts.Series.prototype.addIndicator = function(indicatorID, options) {
                var data = barsTable
                            .chain()
                            .find({instrumentCdAndTp: this.options.id})
                            .simplesort('time', false)
                            .data();
                //Class name for all CDL type of indicators is CDL
                var indicatorObject = new window[_.startsWith(indicatorID.toUpperCase(), 'CDL') ? 'CDL' : indicatorID.toUpperCase()](data, options, indicators);
                var series = this;
                var chart = series.chart;
                var indicatorMetadata = indicatorsMetaData[indicatorID];
                if (indicatorMetadata) {
                    var seriesAndAxisConfArr = indicatorObject.buildSeriesAndAxisConfFromData(indicatorMetadata);
                    //console.log('seriesAndAxisConfArr', seriesAndAxisConfArr);
                    seriesAndAxisConfArr.forEach(function(seriesAndAxisConfArr) {
                        if (seriesAndAxisConfArr.axisConf) {
                            chart.addAxis(seriesAndAxisConfArr.axisConf, false, false, false);
                            indicators.recalculate(chart);
                        }
                        if (seriesAndAxisConfArr.seriesConf) {
                            var conf = _.extend(seriesAndAxisConfArr.seriesConf, {
                                dataGrouping : series.options.dataGrouping,
                                opposite : series.options.opposite
                            });
                            if (indicatorMetadata.onChartIndicator) {
                                conf = _.extend(conf, {
                                    compare : series.options.compare
                                });
                            }
                            console.log('total series before adding indicator series', chart.series.length, ' new series conf', conf);
                            chart.addSeries(conf, false, false);
                        }
                    });
                    chart.redraw();
                    this[indicatorID] = this[indicatorID] || [];
                    this[indicatorID].push(indicatorObject);
                } else {
                    console.error('Unable to add indicator!');
                }
                var dialog_id = chart.renderTo.id.replace("_chart", "");
                var dialog = $('#' + dialog_id);
                dialog.trigger('chart-indicators-changed', chart);
            };
            Highcharts.Series.prototype.removeIndicator = function(indicatorSeriesIDArr) {
                var series = this;
                if (series.options.isInstrument && series.options.id !== 'navigator') {
                    for (var key in indicatorsMetaData) {
                        var each = indicatorsMetaData[key];
                        if (series[each.id]) {//This is a check to find out, if this indicator was loaded for this chart
                            series[each.id].forEach(function (eachInstanceOfTheIndicator, index) {
                                if (eachInstanceOfTheIndicator.isSameInstance(indicatorSeriesIDArr)) {
                                    indicatorSeriesIDArr.forEach(function(e) {
                                        /**
                                         * There could be only 2 things to remove
                                         * 1. Axis   -> "indicatorID-uniqueID"
                                         * 2. series -> "uniqueID"
                                         */
                                        //Delete series
                                        var something = series.chart.get(e);
                                        if (something) {
                                            something.remove(false);
                                        }
                                        //Delete axis
                                        something = series.chart.get(each.id + '-' + e);
                                        if (something) {
                                            something.remove(false);
                                            indicators.recalculate(series.chart);
                                        }
                                    });
                                    series[each.id].splice(index, 1);
                                    return false;
                                }
                            });
                        }
                    }
                }
                this.chart.redraw();
                var dialog_id = this.chart.renderTo.id.replace("_chart", "");
                var dialog = $('#' + dialog_id);
                dialog.trigger('chart-indicators-changed', this.chart);
            };
            /*
             *  Wrap HC's Series.addPoint
             */
            Highcharts.wrap(Highcharts.Series.prototype, 'addPoint', function(proceed, options, redraw, shift, animation) {
                proceed.call(this, options, redraw, shift, animation);
                var series = this;
                console.log('Addpoint called!', series.options.id, series.options.name, series.options.isInstrument);
                if (series.options.isInstrument && series.options.id !== 'navigator') {
                    var time = options[0];
                    var bar = (barsTable.chain()
                        .find({'$and': [{instrumentCdAndTp: series.options.id}, {time: time}]})
                        .simplesort("time", true)
                        .limit(1)
                        .data() || [])[0];
                    if (bar) {
                        for (var key in indicatorsMetaData) {
                            var each = indicatorsMetaData[key];
                            if (series[each.id]) {//This is a check to find out, if this indicator was loaded for this chart
                                series[each.id].forEach(function (eachInstanceOfTheIndicator) {
                                    var indicatorUpdated = eachInstanceOfTheIndicator.addPoint(bar);
                                    indicatorUpdated.forEach(function(iu) {
                                        var indicatorSeries = series.chart.get(iu.id);
                                        if (_.isArray(iu.value)) {
                                            indicatorSeries.addPoint(_.flattenDeep([time, iu.value]));
                                        } else if (iu.value instanceof CDLUpdateObject || iu.value instanceof FractalUpdateObject) {
                                            updateOrAddScatterOrFlagSeriesData(iu, indicatorSeries);
                                        } else {
                                            //iu.color is used by Awesome indicator
                                            if (iu.color) {
                                                indicatorSeries.addPoint([time, iu.value]);
                                                indicatorSeries.data[indicatorSeries.data.length - 1].update({
                                                    color: iu.color
                                                });
                                            } else {
                                                indicatorSeries.addPoint([time, iu.value]);
                                            }
                                        }
                                    });
                                });
                            }
                        }
                    }
                }
            });

            /*
             * Update will be called for all series
             * We do not have to worry about indicator series, because they will not have instance of indicator Classes
             * Wrap HC's Point.update
             */
            Highcharts.wrap(Highcharts.Point.prototype, 'update', function(proceed, options, redraw, animation) {
                proceed.call(this, options, redraw, animation);
                var series = this.series;
                if (series.options.isInstrument && series.options.id !== 'navigator') {
                    var time = this.x || this.time;
                    var bar = (barsTable.chain()
                        .find({'$and': [{instrumentCdAndTp: series.options.id}, {time: time}]})
                        .simplesort("time", true)
                        .limit(1)
                        .data() || [])[0];
                    if (bar) {
                        for (var key in indicatorsMetaData) {
                            var each = indicatorsMetaData[key];
                            if (series[each.id]) {
                                series[each.id].forEach(function (eachInstanceOfTheIndicator) {
                                    var indicatorUpdated = eachInstanceOfTheIndicator.update(bar);
                                    indicatorUpdated.forEach(function(iu) {
                                        var indicatorSeries = series.chart.get(iu.id);
                                        var seriesData = indicatorSeries.data;
                                        if (_.isArray(iu.value)) {
                                            //e.g, dc indicator
                                            seriesData[seriesData.length - 1].update(_.flattenDeep([time, iu.value]));
                                        } else if (iu.value instanceof CDLUpdateObject || iu.value instanceof FractalUpdateObject) {
                                            updateOrAddScatterOrFlagSeriesData(iu, indicatorSeries);
                                        } else {
                                            seriesData[seriesData.length - 1]
                                                .update({
                                                    y: iu.value
                                                });
                                        }
                                    });
                                });
                            }
                        }
                    }
                }
            });
        },

        /*
         * Function to recalculate heights of different sections in a chart
         */
        recalculate: function (chart) {
            var GAP = 5;
            var totalYAxes = chart.yAxis.length;
            totalYAxes--;//Excluding main chart
            totalYAxes--;//Excluding navigator chart
            var heightOfEachSubWindow = Math.round(45 / totalYAxes)-5;
            var topForNextSubWindow = 0;

            if (totalYAxes <= 0) {
                //assign all space to the main chart
                chart.yAxis[0].update({
                    top: '0%',
                    height: '100%'
                }, false);
            }
            else {
                $.each(chart.yAxis, function (index, current_yAxis) {
                    //Main chart - Keeping it at 50%
                    if (index == 0) {
                        current_yAxis.update({
                            top: '0%',
                            height: '50%'
                        }, false);
                        topForNextSubWindow += 50;
                    }
                        //Ignore navigator axis
                    else if (current_yAxis.options && current_yAxis.options.id && current_yAxis.options.id.toLowerCase().indexOf('navigator') != -1) {
                    }
                    else {
                        //I am dividing remaining 45% among all subwindows. If its crossing 100%, the last window will get what is possible out of left over from 100%
                        current_yAxis.update({
                            top: (topForNextSubWindow + GAP) + '%',
                            height: ((topForNextSubWindow + GAP + heightOfEachSubWindow) > 100 ? (100 - topForNextSubWindow - GAP) : heightOfEachSubWindow) + '%',
                            offset: 0
                        }, false);
                        topForNextSubWindow += GAP + heightOfEachSubWindow;
                    }
                });
            }
        },

        appliedPriceString: function (intValue) {
            var ret = 'CLOSE';
            switch (intValue) {
                case indicators.OPEN:
                    ret = 'OPEN';
                    break;
                case indicators.HIGH:
                    ret = 'HIGH';
                    break;
                case indicators.LOW:
                    ret = 'LOW';
                    break;
                case indicators.CLOSE:
                    ret = 'CLOSE';
                    break;
            }
            return ret;
        },

        getIndicatorOrPriceValue: function(data, appliedTo) {
            var price = data.close;
            switch(appliedTo) {
                case this.OPEN: price = data.open; break;
                case this.HIGH: price = data.high; break;
                case this.LOW: price  = data.low; break;
            }
            return price;
        },

        /**
         * Long candle is "candle body" = "70% of Math.abs(high - low)"
         * @param open
         * @param high
         * @param low
         * @param close
         * @returns {boolean}
         */
        isLongCandle : function(open, high, low, close) {
            var bodySize = Math.abs(open - close);
            var candleSize = Math.abs(high - low);
            return bodySize >= (.7 * candleSize);
        },
        /*Return indicators.json data*/
        getIndicatorsJSONData :function()
        {
            return indicatorsMetaData;
        }

    };

    return indicators;

});

/**
 * Created by Mahboob.M on 1/22/16.
 */

KAMA = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateKAMAValue = function (data, index) {
        var fastestSC = 2 / (this.options.fastPeriod + 1);
        var slowestSC = 2 / (this.options.slowPeriod + 1);
        //Change = ABS(Close - Close (10 periods ago))
        var change = Math.abs(this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo)
            - this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo));
        var sum = 0.0;
        for (var i = 0; i < this.options.period; i++) {
            //Volatility = Sum10(ABS(Close - Prior Close))
            sum += Math.abs(this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo)
                - this.indicators.getIndicatorOrPriceValue(this.priceData[index - (i + 1)], this.options.appliedTo));
        }
        var er = change / sum;
        var sc = Math.pow((er * (fastestSC - slowestSC) + slowestSC), 2);
        var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        var preKama = this.indicatorData[index - 1].value;
        var kama = toFixed(preKama + sc * (price - preKama), 4);
        return kama;
    };
    /* KAMA :
    Change = ABS(Close - Close (10 periods ago))
    Volatility = Sum10(ABS(Close - Prior Close))
    ER = Change/Volatility
    fastest SC = 2/(fastest + 1);
    slowest SC = 2/(slowest + 1);
    SC = [ER x (fastest SC - slowest SC) + slowest SC]2
    Current KAMA = Prior KAMA + SC * (Price - Prior KAMA)*/
    for (var index = 0; index < data.length; index++) {
        if (index > (this.options.period - 1)) {
            var kama = this.CalculateKAMAValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: kama });
        } else if (index === (this.options.period - 1)) {
            var kama = toFixed(indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo), 4);
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};


KAMA.prototype = Object.create(IndicatorBase.prototype);
KAMA.prototype.constructor = KAMA;

KAMA.prototype.addPoint = function (data) {
    console.log('Adding KAMA data point : ', data);
    this.priceData.push(data);
    var kama = this.CalculateKAMAValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: kama });
    return [{
        id: this.uniqueID,
        value: kama
    }];
};

KAMA.prototype.update = function (data) {
    console.log('Updating KAMA data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var kama = this.CalculateKAMAValue(this.priceData, index);
    this.indicatorData[index].value = kama;
    return [{
        id: this.uniqueID,
        value: kama
    }];
};

KAMA.prototype.toString = function () {
    return 'KAMA (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/9/16.
 */

LSMA = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateLSMAValue = function (data, index) {
        /* LSMA :
         b= [nsigma(tx) - sigma(t) * sigma(x)]/[n * sigma(t) - sigm(t) * sigm(t)]
         a= (1/n sigma (x)) - (b * (1/nsigma(t)))
         lsma= b * t + a
         */
        var sumT = 0.0, sumX = 0.0, sumTX = 0.0;
        for (var i = 0; i < this.options.period; i++) {
            var price = this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            sumX += price;
            sumT += index - i;
            sumTX += price * (index - i);
        };
        var b = ((this.options.period * sumTX) - (sumT * sumX)) / ((this.options.period * sumT) - (Math.pow(sumT, 2)));
        var n = 1 / this.options.period;
        var a = (n * sumX) - (b * n * sumT);
        var lsma = b * index + a;
        return toFixed(lsma, 4);
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var lsma = this.CalculateLSMAValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: lsma });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    };
};

LSMA.prototype = Object.create(IndicatorBase.prototype);
LSMA.prototype.constructor = LSMA;

LSMA.prototype.addPoint = function (data) {
    console.log('Adding LSMA data point : ', data);
    this.priceData.push(data);
    var lsma = this.CalculateLSMAValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: lsma });
    return [{
        id: this.uniqueID,
        value: lsma
    }];
};

LSMA.prototype.update = function (data) {
    console.log('Updating LSMA data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var lsma = this.CalculateLSMAValue(this.priceData, index);
    this.indicatorData[index].value = lsma;
    return [{
        id: this.uniqueID,
        value: lsma
    }];
};

LSMA.prototype.toString = function () {
    return 'LSMA (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/22/16.
 */

LWMA = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];

    /* LWMA :
    LWMA = SUM(Close(i)*i, N)/SUM(i, N)
    Where: 
    SUM(i, N) — is the total sum of weight coefficients.*/

    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var sum = 0.0;
            var sumI = 0.0;
            for (var i = this.options.period - 1; i >= 0; i--) {
                sum += indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo) * (index - i);
                sumI += index - i;
            }
            var lwma = toFixed(sum / sumI, 4);
            this.indicatorData.push({ time: data[index].time, value: lwma });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

LWMA.prototype = Object.create(IndicatorBase.prototype);
LWMA.prototype.constructor = LWMA;

LWMA.prototype.addPoint = function (data) {
    console.log('Adding LWMA data point : ', data);
    this.priceData.push(data);
    var sum = 0.0;
    var sumI = 0.0;
    for (var i = this.options.period - 1; i >= 0; i--) {
        var index = this.priceData.length - 1;
        sum += this.indicators.getIndicatorOrPriceValue(this.priceData[index - i], this.options.appliedTo) * (index - i);
        sumI += index - i;
    }
    var lwma = toFixed(sum / sumI, 4);
    this.indicatorData.push({ time: data.time, value: lwma });
    return [{
        id: this.uniqueID,
        value: lwma
    }];
};

LWMA.prototype.update = function (data) {
    console.log('Updating LWMA data point : ', data);
    var sum = 0.0, sumI=0.0 ,index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    for (var i = this.options.period - 1; i >= 0; i--) {
        sum += this.indicators.getIndicatorOrPriceValue(this.priceData[index - i], this.options.appliedTo) * (index - i);
        sumI += index - i;
    }
    var lwma = toFixed(sum / sumI, 4);
    this.indicatorData[index].value = lwma;
    return [{
        id: this.uniqueID,
        value: lwma
    }];
};

LWMA.prototype.toString = function () {
    return 'LWMA (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/30/16.
 */
MACD = function (data, options, indicators) {

    options.fastMaType = (options.fastMaType || 'SMA').toUpperCase();
    options.slowMaType = (options.slowMaType || 'SMA').toUpperCase();
    options.signalMaType = (options.signalMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    var slowOptions = { maType: options.slowMaType, period: options.slowPeriod, appliedTo: options.appliedTo },
        fastOprions = { maType: options.fastMaType, period: options.fastPeriod, appliedTo: options.appliedTo },
        signalOptions = { maType: options.signalMaType, period: options.signalPeriod + options.slowPeriod - 1 };
    this.fastMa = new window[options.fastMaType](data, fastOprions, indicators);
    this.slowMa = new window[options.slowMaType](data, slowOptions, indicators);
    this.histogramData = [];
    //3 unique IDs for 3 series to be rendered
    //macd, signal, histogarm
    this.uniqueID = [uuid(), uuid(), uuid()];

    /*
    MACD 
    *MACD Line: (12-day EMA - 26-day EMA)
    * Signal Line: 9-day EMA of MACD Line
    * MACD Histogram: MACD Line - Signal Line
    */
    for (var index = 0; index < data.length; index++) {
        var macdValue = toFixed((this.fastMa.indicatorData[index].value - this.slowMa.indicatorData[index].value), 4);
        this.indicatorData.push({ time: data[index].time, value: macdValue ,close :macdValue});
    }
    this.signalMa = new window[options.signalMaType](this.indicatorData, signalOptions, indicators);
    this.signalData = this.signalMa.indicatorData;

    var index = 0;
    var _this = this;
    this.indicatorData.forEach(function (e) {
        var histogramValue = toFixed((e.value - _this.signalData[index].value), 4);
        _this.histogramData.push({ time: data[index].time, value: histogramValue });
        index++;
    });
};

MACD.prototype = Object.create(IndicatorBase.prototype);
MACD.prototype.constructor = MACD;

MACD.prototype.addPoint = function (data) {
    var fastMa = this.fastMa.addPoint(data)[0].value;
    var slowMa = this.slowMa.addPoint(data)[0].value;
    var macdValue = toFixed((fastMa - slowMa), 4);
    var signalMa = this.signalMa.addPoint({ time: data.time, close: macdValue })[0].value;
    var histogramValue = toFixed((macdValue - signalMa), 4);
    this.signalData = this.signalMa.indicatorData;
    this.histogramData.push({ time: data.time, value: histogramValue });
    this.indicatorData.push({ time: data.time, value: macdValue });
    return [{
        id: this.uniqueID[0],
        value: macdValue
    }, {
        id: this.uniqueID[1],
        value: signalMa
    }, {
        id: this.uniqueID[2],
        value: histogramValue
    }];
};

MACD.prototype.update = function (data) {
    var index = this.indicatorData.length - 1;
    var fastMa = this.fastMa.update(data)[0].value;
    var slowMa = this.slowMa.update(data)[0].value;
    var macdValue = toFixed((fastMa - slowMa), 4);
    var signalMa = this.signalMa.update({ time: data.time, close: macdValue })[0].value;
    var histogramValue = toFixed((macdValue - signalMa), 4);
    this.signalData = this.signalMa.indicatorData;
    this.histogramData[index].value = histogramValue;
    this.indicatorData[index].value = macdValue;
    return [{
        id: this.uniqueID[0],
        value: macdValue
    }, {
        id: this.uniqueID[1],
        value: signalMa
    }, {
        id: this.uniqueID[2],
        value: histogramValue
    }];
};

MACD.prototype.toString = function () {
    return 'MACD (' + this.options.fastPeriod + ', ' + this.options.slowPeriod + ', ' + this.options.signalPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
MACD.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    var macdData = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function (e) {
        macdData.push([e.time, e.value]);
    });
    var signaldata = [];
    this.signalData.forEach(function (e) {
        signaldata.push([e.time, e.value]);
    });
    var histogramData = [];
    this.histogramData.forEach(function (e) {
        histogramData.push([e.time, e.value]);
    });

    return [{
            axisConf: { // Secondary yAxis
                id: indicatorMetadata.id + '-' + this.uniqueID[0],
                title: {
                    text: this.toString(),
                    align: 'high',
                    offset: 0,
                    rotation: 0,
                    y: 10, //Trying to show title inside the indicator chart
                    x: 30+ this.toString().length * 7.5
                },
                lineWidth: 2,
                plotLines: this.options.levels
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[2],
                 name: 'Histogram - ' + this.toString(),
                 data: histogramData,
                 type: 'column',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: 'MACD - ' + this.toString(),
                 data: macdData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[1],
                 name: 'SIGNAL - ' + this.toString(),
                 data: signaldata,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         }];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
MACD.prototype.getIDs = function () {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
MACD.prototype.isSameInstance = function (uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Mahboob.M on 1/30/16.
 */

MAMA = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.smooth = [], this.detrender = [], this.period = [],
    this.I1 = [], this.Q1 = [], this.I2 = [], this.Q2 = [],
    this.Re = [], this.Im = [], this.smoothPeriod = [], this.phase = [];

    this.CalculateMAMAValue = function (data, index) {
        /* MAMA :
         /*FORMULA
         Inputs: Price((H+L)/2),   FastLimit(.5),   SlowLimit(.05);
         Vars: Smooth(0),   Detrender(0),   I1(0),   Q1(0),   jI(0),  jQ(0),  I2(0),  Q2(0),  Re(0),   Im(0),   Period(0),  SmoothPeriod(0),  Phase(0),  DeltaPhase(0),  alpha(0),  MAMA(0),       FAMA(0);
         If CurrentBar > 5 then begin
         Smooth = (4*Price + 3*Price[1] + 2*Price[2] + Price[3]) / 10;
         Detrender = (.0962*Smooth + .5769*Smooth[2] - .5769*Smooth[4] - .0962*Smooth[6])*(.075*Period[1] + .54);
         //Compute InPhase and Quadrature components
         Q1 = (.0962*Detrender + .5769*Detrender[2] - .5769*Detrender[4] - .0962*Detrender[6])*(.075*Period[1] + .54);
         I1 = Detrender[3];
         //{Advance the phase of I1 and Q1 by 90 degrees}
         jI = (.0962*I1 + .5769*I1[2] - .5769*I1[4] - .0962*I1[6])*(.075*Period[1] + .54);
         jQ = (.0962*Q1 + .5769*Q1[2] - .5769*Q1[4] - .0962*Q1[6])*(.075*Period[1] + .54);
         //{Phasor addition for 3 bar averaging)}
         I2 = I1 - jQ;
         Q2 = Q1 + jI;
         //{Smooth the I and Q components before applying the discriminator}
         I2 = .2*I2 + .8*I2[1];
         Q2 = .2*Q2 + .8*Q2[1];
         //{Homodyne Discriminator}
         Re = I2*I2[1] + Q2*Q2[1];
         Im = I2*Q2[1] - Q2*I2[1];
         Re = .2*Re + .8*Re[1];
         Im = .2*Im + .8*Im[1];
         If Im <> 0 and Re <> 0 then Period = 360/ArcTangent(Im/Re);
         If Period > 1.5*Period[1] then Period = 1.5*Period[1];
         If Period < .67*Period[1] then Period = .67*Period[1];
         If Period < 6 then Period = 6;
         If Period > 50 then Period = 50;
         Period = .2*Period + .8*Period[1];
         SmoothPeriod = .33*Period + .67*SmoothPeriod[1];
         If I1 <> 0 then Phase = (ArcTangent(Q1 / I1));
         DeltaPhase = Phase[1] - Phase;
         If DeltaPhase < 1 then DeltaPhase = 1;
         alpha = FastLimit / DeltaPhase;
         If alpha < SlowLimit then alpha = SlowLimit;
         MAMA = alpha*Price + (1 - alpha)*MAMA[1];
         FAMA = .5*alpha*MAMA + (1 - .5*alpha)*FAMA[1];
         End; */
        var mamaValue = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        if (index <= 10) {
            this.smooth.push(0);
            this.detrender.push(0);
            this.I1.push(0);
            this.Q1.push(0);
            this.I2.push(0);
            this.Q2.push(0);
            this.Re.push(0);
            this.Im.push(0);
            this.period.push(0);
            this.smoothPeriod.push(0);
            this.phase.push(0);
        }
        else if (index > 10) {
            this.smooth.push((4 * this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo)
                + 3 * this.indicators.getIndicatorOrPriceValue(data[index - 1], this.options.appliedTo)
                + 2 * this.indicators.getIndicatorOrPriceValue(data[index - 2], this.options.appliedTo)
                + 1 * this.indicators.getIndicatorOrPriceValue(data[index - 3], this.options.appliedTo)) / 10);

            this.detrender.push((0.0962 * this.smooth[index]
                + 0.5769 * this.smooth[index - 2]
                + 0.5769 * this.smooth[index - 4]
                + 0.0962 * this.smooth[index - 6]) * (0.075 * this.period[index - 1] + 0.054));

            //Compute InPhase and Quadrature components
            this.Q1.push((0.0962 * this.detrender[index]
                + 0.5769 * this.detrender[index - 2]
                + 0.5769 * this.detrender[index - 4]
                + 0.0962 * this.detrender[index - 6]) * (0.075 * this.period[index - 1] + 0.054));
            this.I1.push(this.detrender[index - 3]);

            //Advance the this.phase of this.I1 and this.Q1 by 90º
            var jI = (0.0962 * this.I1[index]
                + 0.5769 * this.I1[index - 2]
                + 0.5769 * this.I1[index - 4]
                + 0.0962 * this.I1[index - 6]) * (0.075 * this.period[index - 1] + 0.054);
            var jQ = (0.0962 * this.Q1[index]
                + 0.5769 * this.Q1[index - 2]
                + 0.5769 * this.Q1[index - 4]
                + 0.0962 * this.Q1[index - 6]) * (0.075 * this.period[index - 1] + 0.054);

            //Phasor addition for 3 bar averaging
            this.I2.push(this.I1[index] - jQ);
            this.Q2.push(this.Q1[index] + jI);

            //Smooth the I and Q components before applying the discriminator
            this.I2[index] = 0.2 * this.I2[index] + 0.8 * this.I2[index - 1];
            this.Q2[index] = 0.2 * this.Q2[index] + 0.8 * this.Q2[index - 1];

            //{Homodyne Discriminator}
            this.Re.push(this.I2[index] * this.I2[index - 1] + this.Q2[index] * this.Q2[index - 1]);
            this.Im.push(this.I2[index] * this.Q2[index - 1] - this.Q2[index] * this.I2[index - 1]);

            this.Re[index] = 0.2 * this.Re[index] + 0.8 * this.Re[index - 1];
            this.Im[index] = 0.2 * this.Im[index] + 0.8 * this.Im[index - 1];

            this.period.push(0);
            if (this.Im[index] !== 0.0 && this.Re[index] !== 0.0)
                this.period[index] = (360 / (Math.atan(this.Im[index] / this.Re[index]) * (180.0 / 3.14159265359)));
            if (this.period[index] > 1.5 * this.period[index - 1])
                this.period[index] = (1.5 * this.period[index - 1]);
            if (this.period[index] < 0.67 * this.period[index - 1])
                this.period[index] = (0.67 * this.period[index - 1]);
            if (this.period[index] < 6)
                this.period[index] = 6;
            if (this.period[index] > 50)
                this.period[index] = 50;
            this.period[index] = 0.2 * this.period[index] + 0.8 * this.period[index - 1];
            this.smoothPeriod.push(0.33 * this.period[index] + 0.67 * this.smoothPeriod[index - 1]);

            this.phase.push(0);
            if (this.I1[index] !== 0.0)
                this.phase[index] = Math.atan(this.Q1[index] / this.I1[index]) * (180.0 / 3.14159265359);
            var deltaPhase = this.phase[index - 1] - this.phase[index];
            if (deltaPhase < 1)
                deltaPhase = 1;
            var alpha = this.options.fastLimit / deltaPhase;
            if (alpha < this.options.slowLimit)
                alpha = this.options.slowLimit;
            if (alpha > this.options.fastLimit)
                alpha = this.options.fastLimit;
            mamaValue = alpha * this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo) + (1 - alpha) * this.indicatorData[index - 1].value;
        }
        return toFixed(mamaValue, 4);
    };

    for (var index = 0; index < data.length; index++) {
        var mama = this.CalculateMAMAValue(data, index);
        this.indicatorData.push({ time: data[index].time, value: mama });
        this.priceData.push(data[index]);
    }
};

MAMA.prototype = Object.create(IndicatorBase.prototype);
MAMA.prototype.constructor = MAMA;

MAMA.prototype.addPoint = function (data) {
    console.log('Adding MAMA data point : ', data);
    this.priceData.push(data);
    var mama = this.CalculateMAMAValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: mama });
    return [{
        id: this.uniqueID,
        value: mama
    }];
};

MAMA.prototype.update = function (data) {
    console.log('Updating MAMA data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var mama = this.CalculateMAMAValue(this.priceData, index);
    this.indicatorData[index].value = mama;
    return [{
        id: this.uniqueID,
        value: mama
    }];
};

MAMA.prototype.toString = function () {
    return 'MAMA (' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/9/16.
 */
MASS = function (data, options, indicators) {

    options.singleMaType = (options.singleMaType || 'SMA').toUpperCase();
    options.doubleMaType = (options.doubleMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    /*
    Single EMA = 9-period exponential moving average (EMA) of the high-low differential  
    Double EMA = 9-period EMA of the 9-period EMA of the high-low differential 
    EMA Ratio = Single EMA divided by Double EMA 
    Mass Index = 25-period sum of the EMA Ratio 
   */

    this.calculateMassValue = function (index) {
        var sum = 0;
        for (var i = 0; i < this.options.period ; i++) {
            sum += this.ratioData[index - i].value;
        };
        return toFixed(sum, 4);
    };

    var highLowData = [];
    for (var index = 0; index < data.length; index++) {
        var value = data[index].high - data[index].low;
        highLowData.push({ time: data[index].time, close: value });
    };
    this.singleMA = new window[options.singleMaType](highLowData, { maType: options.singleMaType, period: options.singlePeriod }, indicators)

    singleMAData = [];
    this.singleMA.indicatorData.forEach(function (singleMA) {
        singleMAData.push({ time: singleMA.time, close: singleMA.value });
    });
    this.doubleMA = new window[options.doubleMaType](singleMAData, { maType: options.doubleMaType, period: options.doublePeriod }, indicators);

    var index = 0, _this = this;
    this.ratioData = [];
    this.singleMA.indicatorData.forEach(function (singleMA) {
        var maRatio = 0;
        if (_this.doubleMA.indicatorData[index].value !== 0) { maRatio = singleMA.value / _this.doubleMA.indicatorData[index].value };
        _this.ratioData.push({ time: data[index].time, value: maRatio });
        index++;
    });

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var mass = this.calculateMassValue(index);
            this.indicatorData.push({ time: data[index].time, value: mass });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0 });
        };
    };
};

MASS.prototype = Object.create(IndicatorBase.prototype);
MASS.prototype.constructor = MASS;

MASS.prototype.addPoint = function (data) {
    var index = this.indicatorData.length - 1;
    var highLowDiffValue = data.high - data.low;
    var singleMA = this.singleMA.addPoint({ time: data.time, close: highLowDiffValue })[0].value;
    var doubleMA = this.doubleMA.addPoint({ time: data.time, close: singleMA })[0].value;
    this.ratioData.push({ time: data.time, value: (doubleMA !== 0 ? singleMA / doubleMA : 0) });
    var mass = this.calculateMassValue(index);
    this.indicatorData.push({ time: data.time, value: mass });
    return [{
        id: this.uniqueID,
        value: mass,
    }];
};

MASS.prototype.update = function (data) {
    var index = this.indicatorData.length - 1;
    var highLowDiffValue = data.high - data.low;
    var singleMA = this.singleMA.update({ time: data.time, close: highLowDiffValue })[0].value;
    var doubleMA = this.doubleMA.update({ time: data.time, close: singleMA })[0].value;
    this.ratioData[index].value = doubleMA !== 0 ? singleMA / doubleMA : 0;
    var mass = this.calculateMassValue(index);
    this.indicatorData[index].value = mass;
    return [{
        id: this.uniqueID,
        value: mass
    }];
};

MASS.prototype.toString = function () {
    return 'MASS (' + this.options.singlePeriod + ', ' + this.options.doublePeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

MAX = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateMAXValue = function (data, index) {
        /* MAX :
         max = max price over n, n - period*/
        var max = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        for (var i = 0; i < this.options.period; i++) {
            var tempValue = this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            max = Math.max(max, tempValue);
        }
        return toFixed(max, 4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var max = this.CalculateMAXValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: max });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

MAX.prototype = Object.create(IndicatorBase.prototype);
MAX.prototype.constructor = MAX;

MAX.prototype.addPoint = function (data) {
    console.log('Adding MAX data point : ', data);
    this.priceData.push(data);
    var max = this.CalculateMAXValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: max });
    return [{
        id: this.uniqueID,
        value: max
    }];
};

MAX.prototype.update = function (data) {
    console.log('Updating MAX data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var max = this.CalculateMAXValue(this.priceData, index);
    this.indicatorData[index].value = max;
    return [{
        id: this.uniqueID,
        value: max
    }];
};

MAX.prototype.toString = function () {
    return 'MAX (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

MIN = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateMINValue = function (data, index) {
        /* MIN :
         min = min price over n, n - period*/
        var min = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        for (var i = 0; i < this.options.period; i++) {
            var tempValue = this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            min = Math.min(min, tempValue);
        }
        return toFixed(min, 4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var min = this.CalculateMINValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: min });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

MIN.prototype = Object.create(IndicatorBase.prototype);
MIN.prototype.constructor = MIN;

MIN.prototype.addPoint = function (data) {
    console.log('Adding MIN data point : ', data);
    this.priceData.push(data);
    var min = this.CalculateMINValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: min });
    return [{
        id: this.uniqueID,
        value: min
    }];
};

MIN.prototype.update = function (data) {
    console.log('Updating MIN data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var min = this.CalculateMINValue(this.priceData, index);
    this.indicatorData[index].value = min;
    return [{
        id: this.uniqueID,
        value: min
    }];
};

MIN.prototype.toString = function () {
    return 'MIN (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/2/16.
 */

MOM = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*
    * Formula(OHLC or Candlestick) -
    * 	MOM = CLOSE(i) - CLOSE(i-N)*100
    * 		n - period
    */
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period)) {
            var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var nPrePrice = this.indicators.getIndicatorOrPriceValue(data[index - this.options.period], this.options.appliedTo);
            var mom = toFixed(((price - nPrePrice) * 100), 4);
            this.indicatorData.push({ time: data[index].time, value: mom });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

MOM.prototype = Object.create(IndicatorBase.prototype);
MOM.prototype.constructor = MOM;

MOM.prototype.addPoint = function (data) {
    console.log('Adding MOM data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var mom = toFixed(((price - nPrePrice) * 100), 4);
    this.indicatorData.push({ time: data.time, value: mom });
    return [{
        id: this.uniqueID,
        value: mom
    }];
};

MOM.prototype.update = function (data) {
    console.log('Updating MOM data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var mom = toFixed(((price - nPrePrice) * 100), 4);
    this.indicatorData[index].value = mom;
    return [{
        id: this.uniqueID,
        value: mom
    }];
};

MOM.prototype.toString = function () {
    return 'MOM (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/1/16.
 */
PPO = function (data, options, indicators) {

    options.fastMaType = (options.fastMaType || 'SMA').toUpperCase();
    options.slowMaType = (options.slowMaType || 'SMA').toUpperCase();
    options.signalMaType = (options.signalMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    var slowOptions = { maType: options.slowMaType, period: options.slowPeriod, appliedTo: options.appliedTo },
        fastOprions = { maType: options.fastMaType, period: options.fastPeriod, appliedTo: options.appliedTo },
        signalOptions = { maType: options.signalMaType, period: options.signalPeriod + options.slowPeriod - 1 };
    this.fastMa = new window[options.fastMaType](data, fastOprions, indicators);
    this.slowMa = new window[options.slowMaType](data, slowOptions, indicators);
    this.histogramData = [];
    //3 unique IDs for 3 series to be rendered
    //ppo, signal, histogarm
    this.uniqueID = [uuid(), uuid(), uuid()];

    /*
    PPO 
    *PPO Line: ((12-day EMA - 26-day EMA)/26-day EMA) x 100
    * Signal Line: 9-day EMA of PPO 
    * PPO Histogram: PPO Line - Signal Line
    */
    for (var index = 0; index < data.length; index++) {
        var ppoValue = 0;
        if (this.slowMa.indicatorData[index].value !== 0)
        {
            ppoValue = toFixed((((this.fastMa.indicatorData[index].value - this.slowMa.indicatorData[index].value) / this.slowMa.indicatorData[index].value) * 100), 4)
        };
        this.indicatorData.push({ time: data[index].time, value: ppoValue ,close :ppoValue});
    }
    this.signalMa = new window[options.signalMaType](this.indicatorData, signalOptions, indicators);
    this.signalData = this.signalMa.indicatorData;

    var index = 0;
    var _this = this;
    this.indicatorData.forEach(function (e) {
        var histogramValue = toFixed((e.value - _this.signalData[index].value), 4);
        _this.histogramData.push({ time: data[index].time, value: histogramValue });
        index++;
    });
};

PPO.prototype = Object.create(IndicatorBase.prototype);
PPO.prototype.constructor = PPO;

PPO.prototype.addPoint = function (data) {
    var fastMa = this.fastMa.addPoint(data)[0].value;
    var slowMa = this.slowMa.addPoint(data)[0].value;
    var ppoValue = 0;
    if (slowMa !== 0)
    {
        ppoValue = toFixed((((fastMa - slowMa) / slowMa) * 100), 4);
    };
    var signalMa = this.signalMa.addPoint({ time: data.time, close: ppoValue })[0].value;
    var histogramValue = toFixed((ppoValue - signalMa), 4);
    this.signalData = this.signalMa.indicatorData;
    this.histogramData.push({ time: data.time, value: histogramValue });
    this.indicatorData.push({ time: data.time, value: ppoValue });
    return [{
        id: this.uniqueID[0],
        value: ppoValue
    }, {
        id: this.uniqueID[1],
        value: signalMa
    }, {
        id: this.uniqueID[2],
        value: histogramValue
    }];
};

PPO.prototype.update = function (data) {
    var index = this.indicatorData.length - 1;
    var fastMa = this.fastMa.update(data)[0].value;
    var slowMa = this.slowMa.update(data)[0].value;
    var ppoValue = 0;
    if (slowMa !== 0)
    {
        ppoValue = toFixed((((fastMa - slowMa) / slowMa) * 100), 4);
    };
    var signalMa = this.signalMa.update({ time: data.time, close: ppoValue })[0].value;
    var histogramValue = toFixed((ppoValue - signalMa), 4);
    this.signalData = this.signalMa.indicatorData;
    this.histogramData[index].value = histogramValue;
    this.indicatorData[index].value = ppoValue;
    return [{
        id: this.uniqueID[0],
        value: ppoValue
    }, {
        id: this.uniqueID[1],
        value: signalMa
    }, {
        id: this.uniqueID[2],
        value: histogramValue
    }];
};

PPO.prototype.toString = function () {
    return 'PPO (' + this.options.fastPeriod + ', ' + this.options.slowPeriod + ', ' + this.options.signalPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
PPO.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    var ppoData = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function (e) {
        ppoData.push([e.time, e.value]);
    });
    var signaldata = [];
    this.signalData.forEach(function (e) {
        signaldata.push([e.time, e.value]);
    });
    var histogramData = [];
    this.histogramData.forEach(function (e) {
        histogramData.push([e.time, e.value]);
    });

    return [{
            axisConf: { // Secondary yAxis
                id: indicatorMetadata.id + '-' + this.uniqueID[0],
                title: {
                    text: this.toString(),
                    align: 'high',
                    offset: 0,
                    rotation: 0,
                    y: 10, //Trying to show title inside the indicator chart
                    x: 30+ this.toString().length * 7.5
                },
                lineWidth: 2,
                plotLines: this.options.levels
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[2],
                 name: 'Histogram - ' + this.toString(),
                 data: histogramData,
                 type: 'column',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.ppoHstgrmColor,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: 'PPO - ' + this.toString(),
                 data: ppoData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.ppoStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
         {
             seriesConf: {
                 id: this.uniqueID[1],
                 name: 'SIGNAL - ' + this.toString(),
                 data: signaldata,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.signalLineStroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         }];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
PPO.prototype.getIDs = function () {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
PPO.prototype.isSameInstance = function (uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

ROC = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*
    * Formula(OHLC or Candlestick) -
    * 	ROC = [(Close - Close n periods ago) / (Close n periods ago)] * 100
    * 		n - period
    */
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period)) {
            var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var nPrePrice = this.indicators.getIndicatorOrPriceValue(data[index - this.options.period], this.options.appliedTo);
            var roc = toFixed((((price - nPrePrice) / nPrePrice) * 100), 4);
            this.indicatorData.push({ time: data[index].time, value: roc });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

ROC.prototype = Object.create(IndicatorBase.prototype);
ROC.prototype.constructor = ROC;

ROC.prototype.addPoint = function (data) {
    console.log('Adding ROC data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var roc = toFixed((((price - nPrePrice) / nPrePrice) * 100), 4);
    this.indicatorData.push({ time: data.time, value: roc });
    return [{
        id: this.uniqueID,
        value: roc
    }];
};

ROC.prototype.update = function (data) {
    console.log('Updating ROC data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var price = this.indicators.getIndicatorOrPriceValue(this.priceData[index], this.options.appliedTo);
    var nPrePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - this.options.period], this.options.appliedTo);
    var roc = toFixed((((price - nPrePrice) / nPrePrice) * 100), 4);
    this.indicatorData[index].value = roc;
    return [{
        id: this.uniqueID,
        value: roc
    }];
};

ROC.prototype.toString = function () {
    return 'ROC (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/29/16.
 */

RSI = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateRSIValue = function (data, index) {
        /*
         * Formula -
         * 	rs(t) = avg-gain(n) / avg-loss(n)
         *  rsi(t) = if avg-loss(n) == 0 ? 100 : 100 - (100/ (1+rs(t))
         * 		t - current
         * 		n - period
         */
        var avgGain = 0, avgLoss = 0;
        //Calculate RS - start
        for (var i = 0 ; i < this.options.period; i++) {
            var price1 = this.indicators.getIndicatorOrPriceValue(data[index - (i + 1)], this.options.appliedTo);
            var price2 = this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            if (price2 > price1) avgGain += price2 - price1;
            if (price2 < price1) avgLoss += price1 - price2;
        }
        avgGain /= this.options.period;
        avgLoss /= this.options.period;
        var rs = avgGain / avgLoss;
        //Calculate RS - end

        return toFixed((avgLoss == 0 ? 100 : (100 - (100 / (1 + rs)))),4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var rsi = this.CalculateRSIValue( data, index);
            this.indicatorData.push({ time: data[index].time, value: rsi });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};


RSI.prototype = Object.create(IndicatorBase.prototype);
RSI.prototype.constructor = RSI;

RSI.prototype.addPoint = function (data) {
    console.log('Adding RSI data point : ', data);
    this.priceData.push(data);
    var rsi = this.CalculateRSIValue( this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: rsi });
    return [{
        id: this.uniqueID,
        value: rsi
    }];
};

RSI.prototype.update = function (data) {
    console.log('Updating RSI data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var rsi = this.CalculateRSIValue(this.priceData, index);
    this.indicatorData[index].value = rsi;
    return [{
        id: this.uniqueID,
        value: rsi
    }];
};

RSI.prototype.toString = function () {
    return 'RSI (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/30/16.
 */
SAR = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.ep=[], this.af=[], this.trend=[];
    this.period = 5;
    this.priceData = [];
    this.calculateSAR = function (data, index, isPointUpdate) {
        /*
         Prior SAR: The SAR value for the previous period.
         Extreme Point (EP): The highest high of the current uptrend.
         Acceleration Factor (AF): Starting at .02, AF increases by .02 each
         time the extreme point makes a new high. AF can reach a maximum
         of .20, no matter how long the uptrend extends.
         Current SAR = Prior SAR + Prior AF(Prior EP - Prior SAR)
         13-Apr-10 SAR = 48.28 = 48.13 + .14(49.20 - 48.13)
         */
        var highPrice = data[index].high;
        var lowPrice = data[index].low;

        var sarValue = 0.0;
        if (this.trend[index - 2].value === this.trend[index - 1].value) {
            var prevSarPlusDeltaAF = (this.indicatorData[index - 1].value + (this.af[index - 1].value * (this.ep[index - 1].value - this.indicatorData[index - 1].value)));
            if (this.trend[index - 1].value === "UP") {
                var lowMin = Math.min(data[index - 1].low, data[index - 2].low);
                if ((prevSarPlusDeltaAF) < lowMin) {
                    sarValue = prevSarPlusDeltaAF;
                } else {
                    sarValue = lowMin;
                }
            } else {
                var highMax = Math.max(data[index - 1].high, data[index - 2].high);
                if ((prevSarPlusDeltaAF) > highMax) {
                    sarValue = highMax;
                } else {
                    sarValue = prevSarPlusDeltaAF;
                }
            }
        } else {
            sarValue = this.ep[index - 1].value;
        }

        var epValue = this.trend[index - 1].value === "UP" ?
            (highPrice > this.ep[index - 1].value ? highPrice : this.ep[index - 1].value)
            : (lowPrice < this.ep[index - 1].value ? lowPrice : this.ep[index - 1].value);
        if (isPointUpdate) {
            this.ep.push({ time: data[index].time, value: epValue });
        }
        else {
            this.ep[index] = { time: data[index].time, value: epValue };
        }

        var trendDirection = '';
        if (this.trend[index - 1].value === "UP") {
            if (lowPrice > sarValue) {
                trendDirection = 'UP';
            } else {
                trendDirection = 'DOWN';
            }
        } else if (this.trend[index - 1].value === "DOWN") {
            if (highPrice < sarValue) {
                trendDirection = 'DOWN';
            } else {
                trendDirection = 'UP';
            }
        }
        if (isPointUpdate) {
            this.trend.push({ time: data[index].time, value: trendDirection });
        }
        else {
            this.trend[index] = { time: data[index].time, value: trendDirection };
        }
        // Refer to https://www.tradingview.com/stock-charts-support/index.php/Parabolic_SAR_(SAR)#CALCULATION on updating the af.
        var afValue = 0.0;
        if (this.trend[index].value === this.trend[index - 1].value) {
            if (this.trend[index].value === "UP") {
                if(this.ep[index].value > this.ep[index-1].value){
                    afValue = Math.min(this.af[index-1].value + this.options.acceleration, this.options.maximum);
                } else{
                    afValue = this.af[index-1].value;
                }
            } else {
                if(this.ep[index].value < this.ep[index-1].value){
                    afValue = Math.min(this.af[index-1].value + this.options.acceleration, this.options.maximum);
                } else{
                    afValue = this.af[index-1].value;
                }
            }
        } else {
            afValue = this.options.acceleration;
        }
        if (isPointUpdate) {
            this.af.push({ time: data[index].time, value: afValue });
        }
        else {
            this.af[index] = { time: data[index].time, value: afValue };
        }
        return toFixed(sarValue, 4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index < this.period) {
            this.ep.push({ time: data[index].time, value: 0 });
            this.af.push({ time: data[index].time, value: this.options.acceleration });
            if (index === (this.period - 1)) {
                this.trend.push({ time: data[index].time, value: 'UP' });
            } else {
                this.trend.push({ time: data[index].time, value: '' });
            }
            this.indicatorData.push({ time: data[index].time, value: 0 });
        }
        else if (index === this.period) {
            var sarValue = 0.0, epValue = 0.0;
            for (var i = 0; i < this.period; i++) {
                var highPrice = data[index].high;
                var lowPrice = data[index].low;

                if (sarValue === 0.0) {
                    //value init so that Math.min works properly
                    sarValue = highPrice;
                }
                sarValue = Math.min(sarValue, lowPrice, highPrice);
                epValue = Math.max(sarValue, lowPrice, highPrice);
            }
            this.ep.push({ time: data[index].time, value: epValue });
            this.af.push({ time: data[index].time, value: this.options.acceleration });

            var trendDirection = 'UP';
            if (this.trend[index - 1].value === 'UP') {
                if (lowPrice > sarValue) {
                    trendDirection = 'UP';
                } else {
                    trendDirection = 'DOWN';
                }
            } else if (this.trend[index - 1].value === 'DOWN') {
                if (highPrice < sarValue) {
                    trendDirection = 'DOWN';
                } else {
                    trendDirection = 'UP';
                }
            }
            this.trend.push({ time: data[index].time, value: trendDirection });
            this.indicatorData.push({ time: data[index].time, value: toFixed(sarValue, 4) });
        }
        else {
            var sarValue = this.calculateSAR(data, index ,false);
            this.indicatorData.push({ time: data[index].time, value: sarValue });
        }
        this.priceData.push(data[index]);
    }
};

SAR.prototype = Object.create(IndicatorBase.prototype);
SAR.prototype.constructor = SAR;

SAR.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var sar = this.calculateSAR(this.priceData, this.priceData.length - 1, false);
    this.indicatorData.push({ time: data.time, value: sar });
    return [{
        id: this.uniqueID,
        value: sar
    }];
};

SAR.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var sar = this.calculateSAR(this.priceData, index, true);
    this.indicatorData[index].value = sar;
    return [{
        id: this.uniqueID,
        value: sar
    }];
};

SAR.prototype.toString = function () {
    return 'SAR (' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

SAR.prototype.buildSeriesAndAxisConfFromData = function (indicatorMetadata) {
    var data = [];
    //Prepare the data before sending a configuration
    this.indicatorData.forEach(function (e) {
        data.push([e.time, e.value]);
    });
    return [
        {
            seriesConf: {
                id: this.uniqueID,
                name: 'SAR (' + this.options.acceleration + "," + this.options.maximum + ')',
                data: data,
                lineWidth: 0,
                marker: {
                    enabled: true,
                },
                color: this.options.stroke,
                states: {
                    hover: {
                        enabled: false
                    }
                },
                onChartIndicator: true
            }
        }
    ];
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
SMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];

    /*
     Daily Closing Prices: 11,12,13,14,15,16,17
     First day of 5-day SMA: (11 + 12 + 13 + 14 + 15) / 5 = 13
     Second day of 5-day SMA: (12 + 13 + 14 + 15 + 16) / 5 = 14
     Third day of 5-day SMA: (13 + 14 + 15 + 16 + 17) / 5 = 15
     Do not fill any value in smaData from 0 index to options.period-1 index
     */
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var sum = 0.0;
            for (var i = this.options.period - 1; i >= 0; i--) {
                sum += indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            }
            var sma = toFixed(sum / this.options.period, 4);
            this.indicatorData.push({ time : data[index].time, value : sma });
        } else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
        this.priceData.push(data[index]);
    }
    console.log('Last price data : ', this.priceData[this.priceData.length - 1]);

};

SMA.prototype = Object.create(IndicatorBase.prototype);
SMA.prototype.constructor = SMA;

SMA.prototype.addPoint = function(data) {
    console.log('Adding SMA data point : ', data);
    this.priceData.push(data);
    var sum = 0.0;
    for (var i = this.options.period - 1; i >= 0; i--) {
        sum += this.indicators.getIndicatorOrPriceValue(this.priceData[this.priceData.length - 1 - i], this.options.appliedTo);
    }
    var sma = toFixed(sum / this.options.period, 4);
    this.indicatorData.push({ time : data.time, value : sma });
    return [{
        id : this.uniqueID,
        value : sma
    }];
};

SMA.prototype.update = function(data) {
    console.log('Updating SMA data point : ', data);
    var sum = 0.0, index = this.priceData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    for (var i = this.options.period - 1; i >= 0; i--) {
        sum += this.indicators.getIndicatorOrPriceValue(this.priceData[index - i], this.options.appliedTo);
    }
    var sma = toFixed(sum / this.options.period, 4);
    this.indicatorData[index].value = sma;
    return [{
        id : this.uniqueID,
        value : sma
    }];
};

SMA.prototype.toString = function() {
    return 'SMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/30/16.
 */

SMMA = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateSMMAValue = function (data, index) {
        /* SMMA :
         //PREVSUM = SMMA(i - 1) * N
         //SMMA(i) = (PREVSUM - SMMA(i - 1) + CLOSE(i)) / N
         //SUM1 — is the total sum of closing prices for N periods;
         //PREVSUM — is the smoothed sum of the previous bar;
         //SMMA1 — is the smoothed moving average of the first bar;
         //SMMA(i) — is the smoothed moving average of the current bar (except for the first one);
         //CLOSE(i) — is the current closing price;
         //N — is the smoothing period.*/
        var preSma = this.indicatorData[index - 1].value;
        var preSum = preSma * this.options.period;
        var smmaValue = (preSum - preSma + this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo)) / this.options.period;
        return toFixed(smmaValue, 4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index > (this.options.period - 1)) {
            var smma = this.CalculateSMMAValue( data, index);
            this.indicatorData.push({ time: data[index].time, value: smma });
        }
        else if (index === this.options.period - 1) {
            var sum = 0.0;
            for (var i = 0; i < this.options.period; i++) {
                sum += this.indicators.getIndicatorOrPriceValue(data[i], this.options.appliedTo);
            }
            var smma = toFixed(sum / this.options.period , 4);
            this.indicatorData.push({ time: data[index].time, value: smma });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

SMMA.prototype = Object.create(IndicatorBase.prototype);
SMMA.prototype.constructor = SMMA;

SMMA.prototype.addPoint = function (data) {
    console.log('Adding SMMA data point : ', data);
    this.priceData.push(data);
    var smma = this.CalculateSMMAValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: smma });
    return [{
        id: this.uniqueID,
        value: smma
    }];
};

SMMA.prototype.update = function (data) {
    console.log('Updating SMMA data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var smma = this.CalculateSMMAValue(this.priceData, index);
    this.indicatorData[index].value = smma;
    return [{
        id: this.uniqueID,
        value: smma
    }];
};

SMMA.prototype.toString = function () {
    return 'SMMA (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/8/16.
 */
STOCH = function(data, options, indicators) {

    options.fastDMaType = (options.fastDMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    //2 unique IDs for 2 series to be rendered
    this.uniqueID = [uuid(), uuid()];

    this.calculateStochValue = function (data, index) {
      /*
      %K = (Current Close - Lowest Low)/(Highest High - Lowest Low) * 100
      %D = 3-day SMA of %K
      Lowest Low = lowest low for the look-back period
      Highest High = highest high for the look-back period
      %K is multiplied by 100 to move the decimal point two places
      */
        var lowestLow = data[index].low, hiestHigh = data[index].high;
        for (var i = 0; i < this.options.fastKPeriod; i++) {
            lowestLow = Math.min(data[index - i].low, lowestLow);
            hiestHigh = Math.max(data[index - i].high, hiestHigh);
        };
        var kValue = 0;
        if (hiestHigh - lowestLow !== 0) {
            kValue = ((this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo) - lowestLow) / (hiestHigh - lowestLow)) * 100;
        };

        return toFixed(kValue, 4);
    };
   
    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.fastKPeriod) {
            var kValue = this.calculateStochValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: kValue, close: kValue });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0, close: 0 });
        }

        this.priceData.push(data[index]);
    };

    this.dData = new window[options.fastDMaType](this.indicatorData, { period: this.options.fastDPeriod, maType: this.options.fastDMaType }, indicators);

};

STOCH.prototype = Object.create(IndicatorBase.prototype);
STOCH.prototype.constructor = STOCH;

STOCH.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var kValue = this.calculateStochValue(this.priceData, index);
    var dValue = this.dData.addPoint({ time: data.time, close: kValue })[0].value;
    this.indicatorData.push({ time: data.time, value: kValue });
    return [{
        id: this.uniqueID[0],
        value: kValue
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCH.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var kValue = this.calculateStochValue(this.priceData, index);
    var dValue = this.dData.update({ time: data.time, close: kValue })[0].value;
    this.indicatorData[index].value = kValue;
    return [{
        id: this.uniqueID[0],
        value: kValue
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCH.prototype.toString = function() {
    return 'STOCH (' + this.options.fastKPeriod  + ', ' + this.options.fastDPeriod  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
STOCH.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    //Prepare the data before sending a configuration
    var stochData = [];
    this.indicatorData.forEach(function (e) {
        stochData.push([e.time, e.value]);
    });
    var dData = [];
    this.dData.indicatorData.forEach(function (e) {
        dData.push([e.time, e.value]);
    });

    return [{
        axisConf: { // Secondary yAxis
            id: indicatorMetadata.id + '-' + this.uniqueID[0],
            title: {
                text: this.toString(),
                align: 'high',
                offset: 0,
                rotation: 0,
                y: 10,
                x: 30 + this.toString().length * 7.5
            },
            lineWidth: 2,
            plotLines: this.options.levels
          }
        },
        {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: this.toString(),
                 data: stochData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
        {
            seriesConf: {
                id: this.uniqueID[1],
                name: '%D',
                data: dData,
                type: 'line',
                yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                color: this.options.dStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: false
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
STOCH.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
STOCH.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};

/*
 * Created by Mahboob.M on 2/8/16.
 */

STOCHF = function (data, options, indicators) {
    options.fastKMaType = (options.fastKMaType || 'SMA').toUpperCase();
    options.fastDMaType = (options.fastDMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    this.uniqueID = [uuid(), uuid()];
    /*Fast %K = 100 SMA ( ( ( Close - Low ) / (High - Low ) ),Time Period )
    Fast %D: Simple moving average of Fast K (usually 3-period moving average)
    */
    this.stoch = new STOCH(data, { fastKPeriod: this.options.fastKPeriod,fastDPeriod: this.options.fastDPeriod, appliedTo: this.options.appliedTo }, indicators);
    this.kMa = new window[this.options.fastKMaType](this.stoch.indicatorData, { period: this.options.fastKPeriod, maType: this.options.fastKMaType }, indicators);
    this.indicatorData = this.kMa.indicatorData;
    this.kData = [];
    var _this = this;
    this.indicatorData.forEach(function (e) {
        _this.kData.push({ time: e.time, close: e.value });
    });
    this.dData = new window[options.fastDMaType](this.kData, { period: this.options.fastDPeriod, maType: this.options.fastDMaType }, indicators);
};

STOCHF.prototype = Object.create(IndicatorBase.prototype);
STOCHF.prototype.constructor = STOCHF;

STOCHF.prototype.addPoint = function (data) {
    console.log('Adding STOCHF data point : ', data);
    var stoch = this.stoch.addPoint(data)[0].value;
    var kMa = this.kMa.addPoint({time:data.time , close:stoch})[0].value;
    this.indicatorData = this.kMa.indicatorData;
    var dValue = this.dData.addPoint({time:data.time , close:kMa})[0].value;
    return [{
        id: this.uniqueID[0],
        value: kMa
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCHF.prototype.update = function (data) {
    console.log('Updating STOCHF data point : ', data);
    var stoch = this.stoch.update(data)[0].value;
    var kMa = this.kMa.update({time:data.time , close:stoch})[0].value;
    this.indicatorData = this.kMa.indicatorData;
    var dValue =this.dData.update({time:data.time , close:kMa})[0].value;
    return [{
        id: this.uniqueID[0],
        value: kMa
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCHF.prototype.toString = function () {
    return  'STOCHF (' + this.options.fastKPeriod + ', '+ this.options.fastDPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
STOCHF.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    //Prepare the data before sending a configuration
    var sochfData = [];
    this.indicatorData.forEach(function (e) {
        sochfData.push([e.time, e.value]);
    });
    var dData = [];
    this.dData.indicatorData.forEach(function (e) {
        dData.push([e.time, e.value]);
    });

    return [{
        axisConf: { // Secondary yAxis
            id: indicatorMetadata.id + '-' + this.uniqueID[0],
            title: {
                text: this.toString(),
                align: 'high',
                offset: 0,
                rotation: 0,
                y: 10,
                x: 30+ this.toString().length * 7.5
            },
            lineWidth: 2,
            plotLines: this.options.levels
          }
        },
        {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: this.toString(),
                 data: sochfData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
        {
            seriesConf: {
                id: this.uniqueID[1],
                name: '%D',
                data: dData,
                type: 'line',
                yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                color: this.options.dStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: false
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
STOCHF.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
STOCHF.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};


/**
 * Created by Mahboob.M on 1/29/16.
 */

STOCHRSI = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.rsi = new window['RSI'](data, options, indicators);
    this.CalculateSTOCHRSIValue = function (index) {
        /*
         * Formula -
         * rs(t) = avg-gain(n) / avg-loss(n)
         * rsi(t) = if avg-loss(n) == 0 ? 100 : 100 - (100/ (1+rs(t))
         * StochRSI = (RSI - Lowest Low RSI) / (Highest High RSI - Lowest Low RSI)
         * t - current
         * n - period
         */
        var highestHigh = this.rsi.indicatorData[index].value;
        var lowestLow = this.rsi.indicatorData[index].value;
        for (var i = 0; i < this.options.period; i++) {
            highestHigh = Math.max(highestHigh, this.rsi.indicatorData[index - i].value);
            lowestLow = Math.min(lowestLow, this.rsi.indicatorData[index - i].value);
        }
        var stochrsi = 0;
        if ((highestHigh - lowestLow) !== 0) { stochrsi = (this.rsi.indicatorData[index].value - lowestLow) / (highestHigh - lowestLow) };

        return toFixed(stochrsi, 4);
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.period) {
            var stochrsi = this.CalculateSTOCHRSIValue(index);
            this.indicatorData.push({ time: data[index].time, value: stochrsi });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
    }
};


STOCHRSI.prototype = Object.create(IndicatorBase.prototype);
STOCHRSI.prototype.constructor = STOCHRSI;

STOCHRSI.prototype.addPoint = function (data) {
    console.log('Adding STOCHRSI data point : ', data);
    this.rsi.addPoint(data);
    var stochrsi = this.CalculateSTOCHRSIValue(this.indicatorData.length - 1);
    this.indicatorData.push({ time: data.time, value: stochrsi });
    return [{
        id: this.uniqueID,
        value: stochrsi
    }];
};

STOCHRSI.prototype.update = function (data) {
    console.log('Updating STOCHRSI data point : ', data);
    var index = this.indicatorData.length - 1;
    this.rsi.update(data);
    var stochrsi = this.CalculateSTOCHRSIValue(index);
    this.indicatorData[index].value = stochrsi;
    return [{
        id: this.uniqueID,
        value: stochrsi
    }];
};

STOCHRSI.prototype.toString = function () {
    return ' STOCHRSI (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/*
 * Created by Mahboob.M on 2/8/16.
 */

STOCHS = function (data, options, indicators) {
    options.fastKMaType = (options.fastKMaType || 'SMA').toUpperCase();
    options.slowKMaType = (options.slowKMaType || 'SMA').toUpperCase();
    options.slowDMaType = (options.slowDMaType || 'SMA').toUpperCase();
    IndicatorBase.call(this, data, options, indicators);
    this.uniqueID = [uuid(), uuid()];

    /*Fast %K = 100 SMA ( ( ( Close - Low ) / (High - Low ) ),Time Period )
    Fast %D: Simple moving average of Fast K (usually 3-period moving average)
    */
    this.stochf = new STOCHF(data, { fastKPeriod: this.options.fastKPeriod, fastKMaType: this.options.fastKMaType, appliedTo: this.options.appliedTo }, indicators);
    this.kMa = new window[this.options.slowKMaType](this.stochf.kData, { period: this.options.slowKPeriod, maType: this.options.slowKMaType }, indicators);
    this.indicatorData = this.kMa.indicatorData;
    var kData = [];
    this.indicatorData.forEach(function (e) {
        kData.push({ time: e.time, close: e.value });
    });
    this.dData = new window[options.slowDMaType](kData, { period: this.options.slowDPeriod, maType: this.options.slowDMaType }, indicators);
};

STOCHS.prototype = Object.create(IndicatorBase.prototype);
STOCHS.prototype.constructor = STOCHS;

STOCHS.prototype.addPoint = function (data) {
    console.log('Adding STOCHS data point : ', data);
    var stoch = this.stochf.addPoint(data)[0].value;
    var kMa = this.kMa.addPoint({time:data.time , close:stoch})[0].value;
    this.indicatorData = this.kMa.indicatorData;
    var dValue = this.dData.addPoint({time:data.time , close:kMa})[0].value;
    return [{
        id: this.uniqueID[0],
        value: kMa
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCHS.prototype.update = function (data) {
    console.log('Updating STOCHS data point : ', data);
    var stoch = this.stochf.update(data)[0].value;
    var kMa = this.kMa.update({time:data.time , close:stoch})[0].value;
    this.indicatorData = this.kMa.indicatorData;
    var dValue =this.dData.update({time:data.time , close:kMa})[0].value;
    return [{
        id: this.uniqueID[0],
        value: kMa
    }, {
        id: this.uniqueID[1],
        value: dValue
    }];
};

STOCHS.prototype.toString = function () {
    return  'STOCHS (' + this.options.slowKPeriod + ', '+ this.options.slowDPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * @param indicatorMetadata
 * @returns {*[]}
 */
STOCHS.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
    //Prepare the data before sending a configuration
    var stochsData = [];
    this.indicatorData.forEach(function (e) {
        stochsData.push([e.time, e.value]);
    });
    var dData = [];
    this.dData.indicatorData.forEach(function (e) {
        dData.push([e.time, e.value]);
    });

    return [{
        axisConf: { // Secondary yAxis
            id: indicatorMetadata.id + '-' + this.uniqueID[0],
            title: {
                text: this.toString(),
                align: 'high',
                offset: 0,
                rotation: 0,
                y: 10,
                x: 30+ this.toString().length * 7.5
            },
            lineWidth: 2,
            plotLines: this.options.levels
          }
        },
        {
             seriesConf: {
                 id: this.uniqueID[0],
                 name: this.toString(),
                 data: stochsData,
                 type: 'line',
                 yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                 color: this.options.stroke,
                 lineWidth: this.options.strokeWidth,
                 dashStyle: this.options.dashStyle,
                 onChartIndicator: false
             }
         },
        {
            seriesConf: {
                id: this.uniqueID[1],
                name: '%D',
                data: dData,
                type: 'line',
                yAxis: indicatorMetadata.id + '-' + this.uniqueID[0],
                color: this.options.dStroke,
                lineWidth: this.options.strokeWidth,
                dashStyle: this.options.dashStyle,
                onChartIndicator: false
            }
        }
    ];
};

/**
 * This method will return all IDs that are used to identify data series configuration
 * in the buildSeriesAndAxisConfFromData method.
 * @returns {*[]}
 */
STOCHS.prototype.getIDs = function() {
    return this.uniqueID;
};

/**
 * If all the unique IDs generated by this instance is same as what is passed in the parameter,
 * then we consider this instance to be same as what caller is looking for
 * @param uniqueIDArr
 * @returns {boolean}
 */
STOCHS.prototype.isSameInstance = function(uniqueIDArr) {
    return _.isEqual(uniqueIDArr.sort(), this.uniqueID);
};


/**
 * Created by Mahboob.M on 1/29/16.
 */

SUM = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.CalculateSUMValue = function (data, index) {
        /* SUM :
         sum = sum price over n, n - period*/
        var sum = 0.0;
        for (var i = 0; i < this.options.period; i++) {
            sum += this.indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
        }
        return toFixed(sum, 4);
    };
    for (var index = 0; index < data.length; index++) {
        if (index >= (this.options.period - 1)) {
            var sum = this.CalculateSUMValue(data, index);
            this.indicatorData.push({ time: data[index].time, value: sum });
        } else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

SUM.prototype = Object.create(IndicatorBase.prototype);
SUM.prototype.constructor = SUM;

SUM.prototype.addPoint = function (data) {
    console.log('Adding SUM data point : ', data);
    this.priceData.push(data);
    var sum = this.CalculateSUMValue(this.priceData, this.priceData.length - 1);
    this.indicatorData.push({ time: data.time, value: sum });
    return [{
        id: this.uniqueID,
        value: sum
    }];
};

SUM.prototype.update = function (data) {
    console.log('Updating SUM data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var sum = this.CalculateSUMValue(this.priceData, index);
    this.indicatorData[index].value = sum;
    return [{
        id: this.uniqueID,
        value: sum
    }];
};

SUM.prototype.toString = function () {
    return 'SUM (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob>M on 1/30/16.
 */
T3 = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.ema1 = {}, this.ema2 = {},
    this.gd1 = [], this.gd2 = [], this.gd3 = [];
    this.priceData = [];

    this.CalculateGD =function(data ,key, gd ,appliedTo)
    {
        this.ema1[key] = new EMA(data, {
            period: this.options.period,
            appliedTo: appliedTo 
        }, this.indicators);
        var ema1Data = [];
        this.ema1[key].indicatorData.forEach(function (e) {
            ema1Data.push({ time: e.time, close: e.value });
        });
        this.ema2[key] = new EMA(ema1Data, {
            period: this.options.period,
            appliedTo: this.indicators.CLOSE
        }, this.indicators);
        var ema2Data = [];
        var index = 0;
        var vFactor=this.options.vFactor;
        this.ema2[key].indicatorData.forEach(function (e) {
            ema2Data.push({ time: e.time, close: e.value });
            var gdValue = (ema1Data[index].close * (1 + vFactor)) - (e.value * vFactor);
            gd.push({ time: e.time, close: gdValue });
            index++;
        });
    };
    this.UpdateT3 = function (data, index, key, gd) {
        var ema1Value = this.ema1[key].update(data)[0].value;
        var ema2Value = this.ema2[key].update({ time: data.time, close: ema1Value })[0].value;
        var gdValue = (ema1Value * (1 + this.options.vFactor)) - (ema2Value * this.options.vFactor);
        gd[index] = ({ time: data.time, close: gdValue });
        return {
            time: data.time,
            close: toFixed(gdValue, 4),
        };
    };
    /*
    //Calculate T3 data
    /*
    EMA1 = EMA(x,Period)
    EMA2 = EMA(EMA1,Period)
    GD = EMA1*(1+vFactor)) - (EMA2*vFactor)
    Where vFactor is a volume factor between 0 and 1 which determines how the moving averages responds. A value of 0 returns an EMA. A value of 1 returns DEMA. 
    Tim Tillson advised or preferred a value of 0.7.
    //T3 = GD(GD(GD(t, Period, vFactor), Period, vFactor), Period, vFactor);
    */
    this.CalculateGD(data,'gd1', this.gd1 ,this.options.appliedTo);
    this.CalculateGD(this.gd1,'gd2', this.gd2 ,this.indicators.CLOSE);
    this.CalculateGD(this.gd2,'gd3', this.gd3 ,this.indicators.CLOSE);

    for (var index = 0; index < data.length; index++) {
        this.indicatorData.push({ time: this.gd3[index].time, value: toFixed(this.gd3[index].close, 4) });
        this.priceData.push(data[index]);
    }
};



T3.prototype = Object.create(IndicatorBase.prototype);
T3.prototype.constructor = T3;


AddT3 = function (data, index, key, gd) {
    var ema1Value = this.ema1[key].addPoint(data)[0].value;
    var ema2Value = this.ema2[key].addPoint({ time: data.time, close: ema1Value })[0].value;
    var gdValue = (ema1Value * (1 + this.options.vFactor)) - (ema2Value * this.options.vFactor);
    gd.push({ time: data.time, close: gdValue });
    return {
        time: data.time,
        close: toFixed(gdValue, 4),
    };
}

T3.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var gd1Value = AddT3.call(this, data, index, 'gd1', this.gd1);
    var gd2Value = AddT3.call(this, gd1Value, index, 'gd2', this.gd2);
    var gd3Value = AddT3.call(this, gd2Value, index, 'gd3', this.gd3);
    this.indicatorData.push({ time: data.time, value: gd3Value.close });
    return [{
        id: this.uniqueID,
        value: gd3Value.close
    }];
};


T3.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var index = this.priceData.length - 1;
    var gd1Value = this.UpdateT3(data, index, 'gd1', this.gd1);
    var gd2Value = this.UpdateT3(gd1Value, index, 'gd2', this.gd2);
    var gd3Value = this.UpdateT3(gd2Value, index, 'gd3', this.gd3);
    this.indicatorData.push({ time: data.time, value: gd3Value.close });
    return [{
        id: this.uniqueID,
        value: gd3Value.close
    }];
};

T3.prototype.toString = function () {
    return 'T3 (' + this.options.period + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Arnab Karmakar on 1/14/16.
 */
TEMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.ema1 = null, this.ema2 = null, this.ema3 = null;

    /*
     The Triple Exponential Moving Average (TEMA) of time series 't' is:
     *      EMA1 = EMA(t,period)
     *      EMA2 = EMA(EMA1,period)
     *      EMA3 = EMA(EMA2,period))
     *      TEMA = 3*EMA1 - 3*EMA2 + EMA3
     * Do not fill any value in temaData from 0 index to options.period-1 index
     */
    this.ema1 = new EMA(data, {
        period : options.period,
        appliedTo : options.appliedTo
    }, indicators);
    var ema1Data = [];
    this.ema1.indicatorData.forEach(function(e) {
        ema1Data.push({time : e.time, close : e.value});
    });
    this.ema2 = new EMA(ema1Data, {
        period : options.period,
        appliedTo : indicators.CLOSE
    }, indicators);
    var ema2Data = [];
    this.ema2.indicatorData.forEach(function(e) {
        ema2Data.push({time : e.time, close : e.value});
    });
    this.ema3 = new EMA(ema2Data, {
        period : options.period,
        appliedTo : indicators.CLOSE
    }, indicators);

    for (var index = 0; index < data.length; index++) {
        var tema1Value = this.ema1.indicatorData[index].value;
        var tema2Value = this.ema2.indicatorData[index].value;
        var tema3Value = this.ema3.indicatorData[index].value;
        var tema = toFixed(3 * tema1Value - 3 * tema2Value + tema3Value, 4);
        this.indicatorData.push({ time : data[index].time, value : tema });
    }

};

TEMA.prototype = Object.create(IndicatorBase.prototype);
TEMA.prototype.constructor = TEMA;

TEMA.prototype.addPoint = function(data) {
    var tema1Value = this.ema1.addPoint(data)[0].value;
    var tema2Value = this.ema2.addPoint({ time : data.time, close : tema1Value})[0].value;
    var tema3Value = this.ema3.addPoint({ time : data.time, close : tema2Value})[0].value;
    var tema = toFixed(3 * tema1Value - 3 * tema2Value + tema3Value, 4);
    this.indicatorData.push({ time : data.time, value : tema });
    return [{
        id : this.uniqueID,
        value : tema
    }];
};

TEMA.prototype.update = function(data) {
    var index = this.indicatorData.length - 1;
    var tema1Value = this.ema1.update(data)[0].value;
    var tema2Value = this.ema2.update({ time : data.time, close : tema1Value})[0].value;
    var tema3Value = this.ema3.update({ time : data.time, close : tema2Value})[0].value;
    var tema = toFixed(3 * tema1Value - 3 * tema2Value + tema3Value, 4);
    this.indicatorData[index].value = tema;
    return [{
        id : this.uniqueID,
        value : tema
    }];
};

TEMA.prototype.toString = function() {
    return 'TEMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/2/16.
 */

TRANGE = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    /*
     * Formula -
     * 	trange(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]
     * 		t - current
     * 		n - period
     */
    //Calculate TRANGE data
    for (var index = 0; index < data.length; index++)
    {
        if (index === 0)
        {
            this.indicatorData.push({
                time: data[index].time,
                value: data[index].high - data[index].low
            });
        }
        else
        {
            var price = indicators.getIndicatorOrPriceValue(data[index - 1], this.options.appliedTo);
            var trValue = Math.max(Math.max(data[index].high - data[index].low, Math.abs(data[index].high - price)), (data[index].low - price));
            this.indicatorData.push({ time: data[index].time, value: toFixed(trValue, 4) });
        }
        this.priceData.push(data[index]);
    }
};

TRANGE.prototype = Object.create(IndicatorBase.prototype);
TRANGE.prototype.constructor = TRANGE;

TRANGE.prototype.addPoint = function (data) {
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    /*tr(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]*/
    var prePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - 1], this.options.appliedTo);
    var trValue = Math.max(Math.max(data.high - data.low, Math.abs(data.high - prePrice)), (data.low - prePrice));
    this.indicatorData.push({ time: data.time, value: toFixed(trValue, 4) });
    return [{
        id : this.uniqueID,
        value : trValue
    }];
};

TRANGE.prototype.update = function (data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    /*tr(t) = max[(high - low), abs(high - close(t - 1)), abs(low - close(t - 1))]*/
    var prePrice = this.indicators.getIndicatorOrPriceValue(this.priceData[index - 1], this.options.appliedTo);
    var trValue = Math.max(Math.max(data.high - data.low, Math.abs(data.high - prePrice)), (data.low - prePrice));
    this.indicatorData[this.indicatorData.length - 1].value = toFixed(trValue, 4);
    return [{
        id : this.uniqueID,
        value : trValue
    }];
};

/**
 * @returns {string}
 */
TRANGE.prototype.toString = function() {
    return 'TRANGE (' + this.options.period + ')';
};

/**
 * Created by Arnab Karmakar on 1/15/16.
 */
TRIMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);

    /*
     MA = ( SMA ( SMAm, Nm ) ) / Nm
     Where:
     N = Time periods + 1
     Nm = Round ( N / 2 )
     SMAm = ( Sum ( Price, Nm ) ) / Nm
     *
     *  Do not fill any value in trimaData from 0 index to options.period-1 index
     */
    var Nm = Math.round((this.options.period + 1) / 2) | 0;
    for (var index = 0; index < data.length; index++) {
        if (index === (Nm - 1)) {
            var sum = 0.0;
            for (var i = Nm - 1; i >= 0; i--) {
                sum += indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo);
            }
            this.indicatorData.push({ time : data[index].time, value : toFixed(sum / Nm, 4) });
        } else if(index > (Nm - 1)) {
            var preTrima = this.indicatorData[index - 1].value;
            var price = indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
            var trima = (preTrima * (Nm - 1) + price) / Nm;
            this.indicatorData.push({ time : data[index].time, value : toFixed(trima, 4) });
        } else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
    }

};

TRIMA.prototype = Object.create(IndicatorBase.prototype);
TRIMA.prototype.constructor = TRIMA;

TRIMA.prototype.addPoint = function(data) {
    var Nm = Math.round((this.options.period + 1) / 2) | 0;
    var index = this.indicatorData.length - 1;
    var preTrima = this.indicatorData[index].value;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var trima = (preTrima * (Nm - 1) + price) / Nm;
    trima = toFixed(trima, 4);
    this.indicatorData.push({ time : data.time, value : trima });
    return [{
        id : this.uniqueID,
        value : trima
    }];
};

TRIMA.prototype.update = function(data) {
    var Nm = Math.round((this.options.period + 1) / 2) | 0;
    var index = this.indicatorData.length - 1;
    var preTrima = this.indicatorData[index - 1].value;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var trima = (preTrima * (Nm - 1) + price) / Nm;
    trima = toFixed(trima, 4);
    this.indicatorData[index].value = trima;
    return [{
        id : this.uniqueID,
        value : trima
    }];
};

TRIMA.prototype.toString = function() {
    return 'TRIMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 1/28/16.
 */

TYPPRICE = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    for (var index = 0; index < data.length; index++) {
        var typprice = toFixed(((data[index].high + data[index].low + data[index].close) / 3), 4);
        this.indicatorData.push({ time: data[index].time, value: typprice });
        this.priceData.push(data[index]);
    }
};

TYPPRICE.prototype = Object.create(IndicatorBase.prototype);
TYPPRICE.prototype.constructor = TYPPRICE;

TYPPRICE.prototype.addPoint = function (data) {
    console.log('Adding TYPPRICE data point : ', data);
    this.priceData.push(data);
     /* TYPPRICE :
     typprice =  (High + Low + Close) / 3 */
    var typprice = toFixed(((data.high + data.low + data.close) / 3), 4);
    this.indicatorData.push({ time: data.time, value: typprice });
    return [{
        id: this.uniqueID,
        value: typprice
    }];
};

TYPPRICE.prototype.update = function (data) {
    console.log('Updating TYPPRICE data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var typprice = toFixed(((data.high + data.low + data.close) / 3), 4);
    this.indicatorData[index].value = typprice;
    return [{
        id: this.uniqueID,
        value: typprice
    }];
};

TYPPRICE.prototype.toString = function () {
    return 'TYPPRICE (' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 2/9/16.
 */

ULTOSC = function (data, options, indicators) {
    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];
    this.BP = [], this.TR = [];
    /* ULTOSC 
    BP(Buying Pressure) = Close - Minimum(Low or Prior Close).
    TR(True Range) = Maximum(High or Prior Close)  -  Minimum(Low or Prior Close)
    Average7 = (7-period BP Sum) / (7-period TR Sum)
    Average14 = (14-period BP Sum) / (14-period TR Sum)
    Average28 = (28-period BP Sum) / (28-period TR Sum)
    UO = 100 x [(4 x Average7)+(2 x Average14)+Average28]/(4+2+1)*/
    this.CalculateAVG = function (index, period) {
        var sumBp = 0, sumTr = 0;
        for (var i = 0; i < period; i++) {
            sumBp += this.BP[index - i].value;
            sumTr += this.TR[index - i].value;
        };
        return sumBp / sumTr;
    };

    this.CalculateBRTRValue =function(data,index)
    {
        var price = this.indicators.getIndicatorOrPriceValue(data[index], this.options.appliedTo);
        var prePrice = (index - 1 >= 0) ? this.indicators.getIndicatorOrPriceValue(data[index - 1], this.options.appliedTo) : 0;
        var bp = price - Math.min(data[index].low, prePrice);
        var tr = Math.max(data[index].high, prePrice) - Math.min(data[index].low, prePrice);
        return {
            bp: bp,
            tr: tr
        };
    };

    for (var index = 0; index < data.length; index++) {
        var result = this.CalculateBRTRValue(data, index);
        this.BP.push({ time: data[index].time, value: result.bp });
        this.TR.push({ time: data[index].time, value: result.tr });
    };

    for (var index = 0; index < data.length; index++) {
        if (index >= this.options.thirdPeriod) {
            var firstAvg = this.CalculateAVG(index, this.options.firstPeriod);
            var secondAvg = this.CalculateAVG(index, this.options.secondPeriod);
            var thirdAvg = this.CalculateAVG(index, this.options.thirdPeriod);
            var ultosc = toFixed((100 * ((4 * firstAvg) + (2 * secondAvg) + thirdAvg) / 7), 4);
            this.indicatorData.push({ time: data[index].time, value: ultosc });
        }
        else {
            this.indicatorData.push({ time: data[index].time, value: 0.0 });
        }
        this.priceData.push(data[index]);
    };
};

ULTOSC.prototype = Object.create(IndicatorBase.prototype);
ULTOSC.prototype.constructor = ULTOSC;

ULTOSC.prototype.addPoint = function (data) {
    console.log('Adding ULTOSC data point : ', data);
    this.priceData.push(data);
    var index = this.priceData.length - 1;
    var result = this.CalculateBRTRValue(this.priceData, index);
    this.BP.push({ time: data.time, value: result.bp });
    this.TR.push({ time: data.time, value: result.tr });
    var firstAvg = this.CalculateAVG(index, this.options.firstPeriod);
    var secondAvg = this.CalculateAVG(index, this.options.secondPeriod);
    var thirdAvg = this.CalculateAVG(index, this.options.thirdPeriod);
    var ultosc = toFixed((100 * ((4 * firstAvg) + (2 * secondAvg) + thirdAvg) / 7), 4);
    this.indicatorData.push({ time: data.time, value: ultosc });
    return [{
        id: this.uniqueID,
        value: ultosc
    }];
};

ULTOSC.prototype.update = function (data) {
    console.log('Updating ULTOSC data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var result = this.CalculateBRTRValue(this.priceData, index);
    this.BP[index].value = result.bp;
    this.TR[index].value = result.tr;
    var firstAvg = this.CalculateAVG(index, this.options.firstPeriod);
    var secondAvg = this.CalculateAVG(index, this.options.secondPeriod);
    var thirdAvg = this.CalculateAVG(index, this.options.thirdPeriod);
    var ultosc = toFixed((100 * ((4 * firstAvg) + (2 * secondAvg) + thirdAvg) / 7), 4);
    this.indicatorData[index].value = ultosc;
    return [{
        id: this.uniqueID,
        value: ultosc
    }];
};

ULTOSC.prototype.toString = function () {
    return 'ULTOSC (' + this.options.firstPeriod + ', ' + this.options.secondPeriod + ', ' + this.options.thirdPeriod + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Mahboob.M on 3/2/16.
 */
VAR = function(data, options, indicators) {

    if (_.isUndefined(options.appliedTo)) {
        options.appliedTo = indicators.CLOSE;
    }
    IndicatorBase.call(this, data, options, indicators);
    this.sma = new SMA(data, options, indicators);
    this.priceData = [];
    this.CalculateVARValue = function (data, index) {
        /*
        * Formula -
        // variance  :
        // 	1-Calculate the average (mean) price for the number of periods or observations.
        // 	2-Determine each period's deviation (close less average price).
        // 	3-Square each period's deviation.
        // 	4-Sum the squared deviations.
        // 	5-Divide this sum by the number of observations.
        */
        var sum = 0.0;
        for (var i = this.options.period - 1; i >= 0; i--) {
            sum += Math.pow(indicators.getIndicatorOrPriceValue(data[index - i], this.options.appliedTo) - this.sma.indicatorData[index - i].value, 2)
        }
        var varValue = sum / (this.options.period - 1);
        return toFixed(varValue, 4);
    };
 
   for (var index = 0; index < data.length; index++)
    {
        if (index >= options.period) {
            var varValue = this.CalculateVARValue(data, index);
            this.indicatorData.push({
                time: data[index].time,
                value: varValue
            });
        }
        else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
        this.priceData.push(data[index]);
    }
};

VAR.prototype = Object.create(IndicatorBase.prototype);
VAR.prototype.constructor = VAR;

/**
 * @param data
 * @returns {*[]}
 */
VAR.prototype.addPoint = function(data) {
    this.priceData.push(data);
    this.sma.addPoint(data);
    var index = this.priceData.length - 1;
    var varValue = this.CalculateVARValue(this.priceData, index);
    this.indicatorData.push({
        time: data.time,
        value: varValue
    });
    return [{
        id : this.uniqueID,
        value : varValue
    }];
};

/**
 * @param data
 * @returns {*[]}
 */
VAR.prototype.update = function(data) {
    var index = this.priceData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    this.sma.update(data);
    var varValue = this.CalculateVARValue(this.priceData, index);
    this.indicatorData[index].value = varValue;
    return [{
        id : this.uniqueID,
        value : varValue
    }];
};

/**
 * @returns {string}
 */
VAR.prototype.toString = function() {
    return 'VAR (' + this.options.period + ')';
};

//VAR.prototype.buildSeriesAndAxisConfFromData = function(indicatorMetadata) {
//    var confObjects = IndicatorBase.prototype.buildSeriesAndAxisConfFromData.call(this, indicatorMetadata);
//    confObjects.forEach(function(confObject) {
//        confObject.axisConf.title.x = 73;
//    });
//    return confObjects;
//};

/**
 * Created by Mahboob.M on 1/28/16.
 */

WCLPRICE = function (data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];

    /* WCLPRICE :
    ((Close * 2)+High + Low) / 4*/
    for (var index = 0; index < data.length; index++) {
        var wclprice = toFixed(((data[index].close * 2) + data[index].high + data[index].low) / 4, 4);
        this.indicatorData.push({ time: data[index].time, value: wclprice });
        this.priceData.push(data[index]);
    }
};

WCLPRICE.prototype = Object.create(IndicatorBase.prototype);
WCLPRICE.prototype.constructor = WCLPRICE;

WCLPRICE.prototype.addPoint = function (data) {
    console.log('Adding WCLPRICE data point : ', data);
    this.priceData.push(data);
    var wclprice = toFixed(((data.close * 2) + data.high + data.low) / 4, 4)
    this.indicatorData.push({ time: data.time, value: wclprice });
    return [{
        id: this.uniqueID,
        value: wclprice
    }];
};

WCLPRICE.prototype.update = function (data) {
    console.log('Updating WCLPRICE data point : ', data);
    var index = this.priceData.length - 1;
    this.priceData[index].open = data.open;
    this.priceData[index].high = data.high;
    this.priceData[index].low = data.low;
    this.priceData[index].close = data.close;
    var wclprice = toFixed(((data.close * 2) + data.high + data.low) / 4, 4)
    this.indicatorData[index].value = wclprice;
    return [{
        id: this.uniqueID,
        value: wclprice
    }];
};

WCLPRICE.prototype.toString = function () {
    return 'WCLPRICE (' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};

/**
 * Created by Arnab Karmakar on 1/15/16.
 */
WMA = function(data, options, indicators) {

    IndicatorBase.call(this, data, options, indicators);
    this.priceData = [];

    /*
     WMA = ( Price * n + Price(1) * n-1 + ... Price( n-1 ) * 1) / ( n * ( n + 1 ) / 2 )
     Where: n = time period
     *
     *  Do not fill any value in wmaData from 0 index to options.period-1 index
     */
    for (var index = 0; index < data.length; index++) {
        if(index >= (this.options.period - 1)) {
            var wmaValue = 0.0;
            for (var subIndex = index, count = this.options.period; subIndex >= 0 && count >= 0; count--, subIndex--) {
                var price = indicators.getIndicatorOrPriceValue(data[subIndex], this.options.appliedTo);
                wmaValue += price * count;
            }
            wmaValue = wmaValue / (this.options.period * (this.options.period + 1) / 2);
            wmaValue = toFixed(wmaValue, 4);
            this.indicatorData.push({ time : data[index].time, value : wmaValue });
        } else {
            this.indicatorData.push({ time : data[index].time, value : 0.0 });
        }
        this.priceData.push(data[index]);
    }

};

WMA.prototype = Object.create(IndicatorBase.prototype);
WMA.prototype.constructor = WMA;

WMA.prototype.addPoint = function(data) {
    this.priceData.push(data);
    var index = this.indicatorData.length - 1;
    var price = this.indicators.getIndicatorOrPriceValue(data, this.options.appliedTo);
    var wmaValue = this.options.period * price;
    for (var subIndex = index, count = this.options.period - 1; subIndex >= 0 && count >= 1; count--, subIndex--) {
        var price = this.indicators.getIndicatorOrPriceValue(this.priceData[subIndex], this.options.appliedTo);
        wmaValue += price * count;
    }
    wmaValue = wmaValue / (this.options.period * (this.options.period + 1) / 2);
    wmaValue = toFixed(wmaValue, 4);
    this.indicatorData.push({ time : data.time, value : wmaValue });
    return [{
        id : this.uniqueID,
        value : wmaValue
    }];
};

WMA.prototype.update = function(data) {
    var index = this.indicatorData.length - 1;
    this.priceData[index].open  = data.open;
    this.priceData[index].high  = data.high;
    this.priceData[index].low   = data.low;
    this.priceData[index].close = data.close;
    var wmaValue = 0.0;
    for (var subIndex = index, count = this.options.period; subIndex >= 0 && count >= 1; count--, subIndex--) {
        var price = this.indicators.getIndicatorOrPriceValue(this.priceData[subIndex], this.options.appliedTo);
        wmaValue += price * count;
    }
    wmaValue = wmaValue / (this.options.period * (this.options.period + 1) / 2);
    wmaValue = toFixed(wmaValue, 4);
    this.indicatorData[index].value = wmaValue;
    return [{
        id : this.uniqueID,
        value : wmaValue
    }];
};

WMA.prototype.toString = function() {
    return 'WMA (' + this.options.period  + ', ' + this.indicators.appliedPriceString(this.options.appliedTo) + ')';
};
